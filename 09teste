#!/data/data/com.termux/files/usr/bin/bash

# ============================================
# SISTEMA COMPLETO DE MINERA√á√ÉO TERMUX
# COM SISTEMA DE LOGS AVAN√áADO E DETALHADO
# ============================================

# Configura√ß√µes
WALLET="3P8LjBgV7xH3qDq9eQaRqMXr1kQHbd6u3E"
WORKER="termux_$(date +%s)"
DISCORD_WEBHOOK="https://discord.com/api/webhooks/1469189341715894366/uYz_XcAcox4DCzjBglokELEUp8MpV8HA2lP6ITCbXGCdVTng_8VZFNNY2YdeVB73O8Oj"
POOL_URL="randomxmonero.auto.nicehash.com:9200"
BTC_PRICE=43000
MIN_HASHRATE=50
MAX_HASHRATE=150

# Sistema de logs avan√ßado
LOG_DIR="$HOME/mining_logs"
LOG_TYPES=("system" "mining" "performance" "errors" "network" "security" "financial" "debug")
LOG_RETENTION_DAYS=30

# Cores para terminal
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Banner
clear
echo -e "${CYAN}"
cat << "EOF"
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           SISTEMA DE MINERA√á√ÉO TERMUX - LOGS AVAN√áADOS      ‚ïë
‚ïë              Sistema de Logs Detalhados em Tempo Real       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
echo -e "${NC}"
echo ""

# ============= SISTEMA DE LOGS AVAN√áADO =============

# Inicializar sistema de logs
init_log_system() {
    echo -e "${BLUE}[*]${NC} Inicializando sistema de logs avan√ßado..."
    
    # Criar diret√≥rio principal de logs
    mkdir -p "$LOG_DIR"
    mkdir -p "$LOG_DIR/archives"
    mkdir -p "$LOG_DIR/stats"
    mkdir -p "$LOG_DIR/backups"
    
    # Criar arquivos de log para cada tipo
    for log_type in "${LOG_TYPES[@]}"; do
        touch "$LOG_DIR/${log_type}.log"
    done
    
    # Arquivos especiais
    touch "$LOG_DIR/audit_trail.log"
    touch "$LOG_DIR/session_history.log"
    touch "$LOG_DIR/performance_metrics.log"
    
    # Configurar logrotate
    create_logrotate_config
    
    echo -e "${GREEN}[+]${NC} Sistema de logs inicializado em: $LOG_DIR"
    echo -e "${GREEN}[+]${NC} Tipos de logs: ${LOG_TYPES[*]}"
    
    # Log inicial
    log_system "SYSTEM_INIT" "Sistema de logs inicializado" "INFO" "high"
}

# Fun√ß√£o principal de log com m√∫ltiplos n√≠veis
log_entry() {
    local log_type="$1"
    local category="$2"
    local message="$3"
    local level="$4"
    local priority="${5:-medium}"
    local module="${6:-main}"
    
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S.%3N')
    local log_id="LOG_$(date +%s%N | cut -c1-13)_$(shuf -i 1000-9999 -n 1)"
    local hostname=$(hostname)
    local pid=$$
    local user=$(whoami)
    
    # Cores baseadas no n√≠vel
    case "$level" in
        "DEBUG") local color="${BLUE}" ;;
        "INFO") local color="${GREEN}" ;;
        "WARN") local color="${YELLOW}" ;;
        "ERROR") local color="${RED}" ;;
        "CRITICAL") local color="${MAGENTA}" ;;
        *) local color="${NC}" ;;
    esac
    
    # Formatar entrada de log
    local log_entry="[$timestamp] [$log_id] [PID:$pid] [USER:$user] [HOST:$hostname] [LEVEL:$level] [PRIORITY:$priority] [MODULE:$module] [CATEGORY:$category] - $message"
    
    # Exibir no terminal com cores
    echo -e "${color}[${level}]${NC} ${timestamp} [${category}] ${message}"
    
    # Salvar em arquivo espec√≠fico
    echo "$log_entry" >> "$LOG_DIR/${log_type}.log"
    
    # Salvar em log consolidado
    echo "$log_entry" >> "$LOG_DIR/all_logs_consolidated.log"
    
    # Salvar em audit trail
    echo "[AUDIT] $log_entry" >> "$LOG_DIR/audit_trail.log"
    
    # Salvar em hist√≥rico de sess√£o
    echo "$log_id|$timestamp|$level|$category|$message" >> "$LOG_DIR/session_history.log"
    
    # Enviar para Discord se for importante
    if [[ "$level" == "ERROR" || "$level" == "CRITICAL" || "$priority" == "high" ]]; then
        send_log_to_discord "$log_id" "$level" "$category" "$message"
    fi
    
    # Atualizar estat√≠sticas
    update_log_stats "$log_type" "$level"
    
    return 0
}

# Fun√ß√µes espec√≠ficas para cada tipo de log
log_system() {
    local category="$1"
    local message="$2"
    local level="${3:-INFO}"
    local priority="${4:-medium}"
    log_entry "system" "$category" "$message" "$level" "$priority" "system_module"
}

log_mining() {
    local category="$1"
    local message="$2"
    local level="${3:-INFO}"
    local priority="${4:-medium}"
    log_entry "mining" "$category" "$message" "$level" "$priority" "mining_module"
}

log_performance() {
    local category="$1"
    local message="$2"
    local level="${3:-INFO}"
    local priority="${4:-medium}"
    log_entry "performance" "$category" "$message" "$level" "$priority" "performance_module"
}

log_error() {
    local category="$1"
    local message="$2"
    local priority="${3:-high}"
    log_entry "errors" "$category" "$message" "ERROR" "$priority" "error_handler"
}

log_network() {
    local category="$1"
    local message="$2"
    local level="${3:-INFO}"
    log_entry "network" "$category" "$message" "$level" "medium" "network_module"
}

log_security() {
    local category="$1"
    local message="$2"
    local level="${3:-WARN}"
    log_entry "security" "$category" "$message" "$level" "high" "security_module"
}

log_financial() {
    local category="$1"
    local message="$2"
    local level="${3:-INFO}"
    log_entry "financial" "$category" "$message" "$level" "high" "financial_module"
}

log_debug() {
    local category="$1"
    local message="$2"
    log_entry "debug" "$category" "$message" "DEBUG" "low" "debug_module"
}

# Configurar logrotate
create_logrotate_config() {
    cat > "$LOG_DIR/logrotate.config" << EOF
# Configura√ß√£o de rota√ß√£o de logs
$LOG_DIR/*.log {
    daily
    rotate $LOG_RETENTION_DAYS
    compress
    delaycompress
    missingok
    notifempty
    create 644 $(whoami) $(whoami)
    dateext
    dateformat -%Y%m%d
    extension .log.gz
    postrotate
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Logs rotacionados" >> $LOG_DIR/system.log
    endscript
}

# Logs consolidadas
$LOG_DIR/all_logs_consolidated.log {
    weekly
    rotate 8
    compress
    delaycompress
}
EOF
}

# Atualizar estat√≠sticas de logs
update_log_stats() {
    local log_type="$1"
    local level="$2"
    local stats_file="$LOG_DIR/stats/log_statistics.json"
    
    # Criar arquivo de estat√≠sticas se n√£o existir
    if [ ! -f "$stats_file" ]; then
        echo '{"total_logs": 0, "by_type": {}, "by_level": {}, "by_hour": {}, "last_update": ""}' > "$stats_file"
    fi
    
    # Atualizar estat√≠sticas
    local stats=$(cat "$stats_file")
    local hour=$(date +%H)
    
    # Incrementar contadores
    local total=$(echo "$stats" | jq '.total_logs + 1')
    local type_count=$(echo "$stats" | jq --arg type "$log_type" '.by_type[$type] // 0 + 1')
    local level_count=$(echo "$stats" | jq --arg level "$level" '.by_level[$level] // 0 + 1')
    local hour_count=$(echo "$stats" | jq --arg hour "$hour" '.by_hour[$hour] // 0 + 1')
    
    # Atualizar JSON
    stats=$(echo "$stats" | jq \
        --argjson total "$total" \
        --arg type "$log_type" \
        --argjson type_count "$type_count" \
        --arg level "$level" \
        --argjson level_count "$level_count" \
        --arg hour "$hour" \
        --argjson hour_count "$hour_count" \
        '.total_logs = $total |
         .by_type[$type] = $type_count |
         .by_level[$level] = $level_count |
         .by_hour[$hour] = $hour_count |
         .last_update = "'$(date -Iseconds)'"')
    
    echo "$stats" > "$stats_file"
}

# Enviar log para Discord
send_log_to_discord() {
    local log_id="$1"
    local level="$2"
    local category="$3"
    local message="$4"
    
    local color=0
    case "$level" in
        "INFO") color=65280 ;;
        "WARN") color=16776960 ;;
        "ERROR") color=16711680 ;;
        "CRITICAL") color=255 ;;
        *) color=10070709 ;;
    esac
    
    local embed=$(cat << EOF
{
    "embeds": [{
        "title": "üìä LOG REPORT - $level",
        "color": $color,
        "fields": [
            {"name": "Log ID", "value": "`$log_id`", "inline": true},
            {"name": "Category", "value": "`$category`", "inline": true},
            {"name": "Level", "value": "`$level`", "inline": true},
            {"name": "Message", "value": "```$message```", "inline": false},
            {"name": "Timestamp", "value": "<t:$(date +%s):R>", "inline": true},
            {"name": "Host", "value": "`$(hostname)`", "inline": true}
        ],
        "timestamp": "$(date -Iseconds)",
        "footer": {"text": "Termux Mining Logger"}
    }]
}
EOF
    )
    
    curl -s -H "Content-Type: application/json" -X POST -d "$embed" "$DISCORD_WEBHOOK" >/dev/null 2>&1 &
}

# ============= INSTALA√á√ÉO DO XMRIG =============

install_xmrig() {
    log_system "INSTALLATION" "Iniciando instala√ß√£o do XMRig" "INFO" "high"
    
    # Parar inst√¢ncias existentes
    pkill -9 xmrig 2>/dev/null
    log_debug "PROCESS" "Processos XMRig anteriores finalizados"
    
    # Limpar instala√ß√µes antigas
    rm -rf ~/xmrig* 2>/dev/null
    log_debug "CLEANUP" "Arquivos antigos removidos"
    
    # Instalar depend√™ncias
    log_system "DEPENDENCIES" "Instalando depend√™ncias necess√°rias" "INFO"
    pkg install -y wget tar git python curl jq bc libuv libuv-dev libhwloc-dev openssl-dev -y 2>&1 | tee -a "$LOG_DIR/installation.log"
    
    if [ ${PIPESTATUS[0]} -eq 0 ]; then
        log_system "DEPENDENCIES" "Depend√™ncias instaladas com sucesso" "INFO"
    else
        log_error "DEPENDENCIES" "Falha ao instalar depend√™ncias"
    fi
    
    # Baixar XMRig
    log_system "DOWNLOAD" "Baixando XMRig v6.21.3 para ARM64" "INFO"
    
    cd ~
    local download_url="https://github.com/xmrig/xmrig/releases/download/v6.21.3/xmrig-6.21.3-linux-arm64.tar.gz"
    
    if wget --progress=dot:giga --timeout=60 --tries=3 "$download_url" -O xmrig.tar.gz 2>&1 | tee -a "$LOG_DIR/download.log"; then
        log_system "DOWNLOAD" "XMRig baixado com sucesso" "INFO"
        
        # Extrair
        log_system "EXTRACTION" "Extraindo arquivos..." "INFO"
        if tar -xzf xmrig.tar.gz --strip-components=1 2>&1 | tee -a "$LOG_DIR/extraction.log"; then
            log_system "EXTRACTION" "Arquivos extra√≠dos com sucesso" "INFO"
            
            # Verificar bin√°rio
            if [ -f "xmrig" ]; then
                chmod +x xmrig
                
                # Testar vers√£o
                local version_output=$(./xmrig --version 2>&1)
                if echo "$version_output" | grep -q "XMRig"; then
                    log_system "VERIFICATION" "XMRig instalado - Vers√£o: $(echo "$version_output" | head -1)" "INFO"
                    log_performance "BENCHMARK" "Bin√°rio verificado e funcional"
                    
                    # Testar minera√ß√£o r√°pida
                    test_miner_functionality
                    
                    return 0
                else
                    log_error "VERIFICATION" "Falha ao verificar vers√£o do XMRig"
                fi
            else
                log_error "EXTRACTION" "Bin√°rio xmrig n√£o encontrado ap√≥s extra√ß√£o"
            fi
        else
            log_error "EXTRACTION" "Falha ao extrair arquivos"
        fi
    else
        log_error "DOWNLOAD" "Falha ao baixar XMRig"
        log_network "CONNECTIVITY" "Verificando conectividade com GitHub..."
        
        # Testar conectividade
        if ping -c 3 github.com >/dev/null 2>&1; then
            log_network "CONNECTIVITY" "Conectividade OK com GitHub"
        else
            log_error "CONNECTIVITY" "Sem conectividade com GitHub"
        fi
    fi
    
    # Se falhar, tentar m√©todo alternativo
    log_system "FALLBACK" "Tentando m√©todo de instala√ß√£o alternativo" "WARN"
    compile_xmrig_from_source
}

# Compilar XMRig do c√≥digo-fonte
compile_xmrig_from_source() {
    log_system "COMPILATION" "Iniciando compila√ß√£o do c√≥digo-fonte" "INFO"
    
    # Instalar depend√™ncias de compila√ß√£o
    log_system "COMPILATION_DEPS" "Instalando depend√™ncias de compila√ß√£o" "INFO"
    pkg install -y build-essential cmake git -y 2>&1 | tee -a "$LOG_DIR/compilation.log"
    
    # Clonar reposit√≥rio
    log_system "GIT_CLONE" "Clonando reposit√≥rio do XMRig" "INFO"
    if git clone https://github.com/xmrig/xmrig.git xmrig-source 2>&1 | tee -a "$LOG_DIR/git.log"; then
        cd xmrig-source
        
        # Criar diret√≥rio de build
        mkdir build
        cd build
        
        # Configurar
        log_system "CMAKE" "Configurando build com CMake" "INFO"
        if cmake .. -DCMAKE_BUILD_TYPE=Release -DWITH_HTTP=ON 2>&1 | tee -a "$LOG_DIR/cmake.log"; then
            log_system "CMAKE" "CMake configuration successful" "INFO"
            
            # Compilar
            log_system "MAKE" "Compilando XMRig (isso pode levar alguns minutos)" "INFO"
            local cpu_cores=$(nproc)
            log_performance "COMPILATION" "Usando $cpu_cores n√∫cleos para compila√ß√£o"
            
            if make -j$cpu_cores 2>&1 | tee -a "$LOG_DIR/make.log"; then
                if [ -f "xmrig" ]; then
                    cp xmrig ~/xmrig
                    cd ~
                    chmod +x xmrig
                    log_system "COMPILATION" "XMRig compilado com sucesso" "INFO"
                    return 0
                else
                    log_error "COMPILATION" "Bin√°rio n√£o gerado ap√≥s compila√ß√£o"
                fi
            else
                log_error "COMPILATION" "Falha na compila√ß√£o"
            fi
        else
            log_error "CMAKE" "Falha na configura√ß√£o do CMake"
        fi
    else
        log_error "GIT_CLONE" "Falha ao clonar reposit√≥rio"
    fi
    
    return 1
}

# Testar funcionalidade do minerador
test_miner_functionality() {
    log_system "TESTING" "Testando funcionalidade do minerador" "INFO"
    
    # Testar conex√£o com pool
    log_network "POOL_TEST" "Testando conex√£o com pool: $POOL_URL"
    if timeout 10 nc -z $(echo "$POOL_URL" | cut -d: -f1) $(echo "$POOL_URL" | cut -d: -f2) 2>/dev/null; then
        log_network "POOL_TEST" "Conex√£o com pool bem-sucedida" "INFO"
    else
        log_error "POOL_TEST" "N√£o foi poss√≠vel conectar ao pool"
    fi
    
    # Testar API local
    log_system "API_TEST" "Testando API HTTP local" "INFO"
    if timeout 5 curl -s http://127.0.0.1:8080 >/dev/null 2>&1; then
        log_system "API_TEST" "API HTTP funcionando" "INFO"
    else
        log_debug "API_TEST" "API HTTP n√£o respondendo (pode ser normal na primeira execu√ß√£o)"
    fi
}

# ============= CONFIGURA√á√ÉO DETALHADA =============

create_detailed_config() {
    log_system "CONFIGURATION" "Criando configura√ß√£o detalhada do minerador" "INFO"
    
    cat > ~/config_detailed.json << EOF
{
    "autosave": true,
    "autosave-interval": 30,
    "background": false,
    "colors": true,
    "title": true,
    "cpu": true,
    "opencl": false,
    "cuda": false,
    "pools": [
        {
            "url": "$POOL_URL",
            "user": "$WALLET.$WORKER",
            "pass": "x",
            "keepalive": true,
            "tls": false,
            "rig-id": "$WORKER",
            "nicehash": true,
            "tls-fingerprint": null,
            "daemon": false,
            "socks5": null,
            "self-select": null
        }
    ],
    "print-time": 30,
    "health-print-time": 60,
    "retries": 5,
    "retry-pause": 5,
    "donate-level": 1,
    "donate-over-proxy": 1,
    "log-file": "$LOG_DIR/xmrig_output.log",
    "syslog": false,
    "max-cpu-usage": 80,
    "cpu-priority": 0,
    "cpu-max-threads-hint": 75,
    "cpu-affinity": null,
    "cpu-optimizations": true,
    "hw-aes": true,
    "asm": true,
    "randomx-init": 1,
    "randomx-mode": "auto",
    "randomx-1gb-pages": false,
    "randomx-wrmsr": null,
    "randomx-no-rdmsr": false,
    "argon2-impl": null,
    "argon2": [
        "1",
        "0"
    ],
    "astrobwt-max-size": 550,
    "astrobwt-avx2": false,
    "cn-heavy": [
        "0",
        "0"
    ],
    "cn-lite": [
        "0",
        "0"
    ],
    "cn-pico": [
        "0",
        "0"
    ],
    "cn/0": false,
    "cn/1": false,
    "cn/2": false,
    "cn-lite/0": false,
    "cn-lite/1": false,
    "cn-lite/2": false,
    "cn-pico": false,
    "rx": [
        "0"
    ],
    "rx/wow": [
        "0"
    ],
    "rx/arq": [
        "0"
    ],
    "rx/loki": [
        "0"
    ],
    "rx/keva": [
        "0"
    ],
    "argon2": [
        "0"
    ],
    "astrobwt": [
        "0"
    ],
    "kawpow": [
        "0"
    ],
    "http": {
        "enabled": true,
        "host": "127.0.0.1",
        "port": 8080,
        "access-token": null,
        "restricted": true,
        "workers-access": false
    },
    "api": {
        "id": null,
        "worker-id": null
    },
    "dns": {
        "ipv6": false,
        "ttl": 30
    },
    "verbose": 0,
    "dry-run": false,
    "user-agent": "XMRig/6.21.3",
    "watch": false,
    "pause-on-battery": false,
    "pause-on-active": false
}
EOF

    log_system "CONFIGURATION" "Configura√ß√£o detalhada criada: ~/config_detailed.json" "INFO"
    log_debug "CONFIG_DETAILS" "Wallet: $WALLET, Worker: $WORKER, Pool: $POOL_URL"
}

# ============= SISTEMA DE MONITORAMENTO AVAN√áADO =============

create_advanced_monitoring() {
    log_system "MONITORING" "Criando sistema de monitoramento avan√ßado" "INFO"
    
    # Script de monitoramento de performance
    cat > ~/monitor_performance.sh << EOF
#!/data/data/com.termux/files/usr/bin/bash

LOG_DIR="$LOG_DIR"
INTERVAL=30  # segundos
MAX_TEMP=70  # temperatura m√°xima segura

log_metric() {
    local metric=\$1
    local value=\$2
    local unit=\$3
    echo "\$(date '+%Y-%m-%d %H:%M:%S') | \$metric | \$value | \$unit" >> "\$LOG_DIR/performance_metrics.log"
}

while true; do
    # Coletar m√©tricas de CPU
    CPU_USAGE=\$(top -bn1 | grep "CPU" | head -1 | awk '{print \$2}' | cut -d'%' -f1)
    CPU_FREQ=\$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq 2>/dev/null || echo "0")
    CPU_FREQ=\$((CPU_FREQ / 1000))
    
    # Coletar temperatura
    if [ -f "/sys/class/thermal/thermal_zone0/temp" ]; then
        TEMP=\$(cat /sys/class/thermal/thermal_zone0/temp)
        TEMP=\$((TEMP / 1000))
    else
        TEMP=0
    fi
    
    # Coletar mem√≥ria
    MEM_TOTAL=\$(free -m | grep "Mem:" | awk '{print \$2}')
    MEM_USED=\$(free -m | grep "Mem:" | awk '{print \$3}')
    MEM_PERCENT=\$((MEM_USED * 100 / MEM_TOTAL))
    
    # Coletar rede
    NET_RX=\$(cat /proc/net/dev | grep "wlan0\|rmnet" | head -1 | awk '{print \$2}')
    NET_TX=\$(cat /proc/net/dev | grep "wlan0\|rmnet" | head -1 | awk '{print \$10}')
    
    # Coletar informa√ß√µes do minerador
    XMRIG_PID=\$(pgrep xmrig)
    if [ -n "\$XMRIG_PID" ]; then
        XMRIG_CPU=\$(ps -p \$XMRIG_PID -o %cpu | tail -1 | awk '{print \$1}')
        XMRIG_MEM=\$(ps -p \$XMRIG_PID -o %mem | tail -1 | awk '{print \$1}')
        MINER_STATUS="ACTIVE"
    else
        XMRIG_CPU=0
        XMRIG_MEM=0
        MINER_STATUS="INACTIVE"
    fi
    
    # Logar m√©tricas
    log_metric "CPU_USAGE" "\$CPU_USAGE" "%"
    log_metric "CPU_FREQ" "\$CPU_FREQ" "MHz"
    log_metric "TEMPERATURE" "\$TEMP" "¬∞C"
    log_metric "MEMORY_USAGE" "\$MEM_PERCENT" "%"
    log_metric "MINER_STATUS" "\$MINER_STATUS" ""
    log_metric "MINER_CPU" "\$XMRIG_CPU" "%"
    log_metric "MINER_MEM" "\$XMRIG_MEM" "%"
    
    # Alertas de temperatura
    if [ \$TEMP -gt \$MAX_TEMP ]; then
        echo "[CRITICAL] Temperatura cr√≠tica: \${TEMP}¬∞C" >> "\$LOG_DIR/alerts.log"
        # Opcional: reduzir prioridade ou parar
        if [ -n "\$XMRIG_PID" ]; then
            renice 19 -p \$XMRIG_PID
        fi
    fi
    
    # Gerar relat√≥rio peri√≥dico
    if [ \$(date +%M) == "00" ] || [ \$(date +%M) == "30" ]; then
        create_performance_report
    fi
    
    sleep \$INTERVAL
done

create_performance_report() {
    REPORT_FILE="\$LOG_DIR/stats/performance_report_\$(date +%Y%m%d_%H%M%S).json"
    
    cat > "\$REPORT_FILE" << REPORT_EOF
{
    "timestamp": "\$(date -Iseconds)",
    "metrics": {
        "cpu_usage": "\$CPU_USAGE",
        "cpu_frequency": "\$CPU_FREQ",
        "temperature": "\$TEMP",
        "memory_usage": "\$MEM_PERCENT",
        "miner_status": "\$MINER_STATUS",
        "miner_cpu": "\$XMRIG_CPU",
        "miner_memory": "\$XMRIG_MEM"
    },
    "system": {
        "hostname": "\$(hostname)",
        "uptime": "\$(uptime -p)",
        "kernel": "\$(uname -r)"
    },
    "alerts": \$(if [ -f "\$LOG_DIR/alerts.log" ]; then tail -5 "\$LOG_DIR/alerts.log" | jq -R -s 'split("\n") | map(select(. != ""))'; else echo '[]'; fi)
}
REPORT_EOF
}
EOF

    chmod +x ~/monitor_performance.sh
    log_system "MONITORING" "Script de monitoramento de performance criado" "INFO"
}

# ============= SISTEMA DE RELAT√ìRIOS DETALHADOS =============

create_detailed_reporting() {
    log_system "REPORTING" "Criando sistema de relat√≥rios detalhados" "INFO"
    
    cat > ~/generate_reports.sh << 'EOF'
#!/data/data/com.termux/files/usr/bin/bash

LOG_DIR="$HOME/mining_logs"
REPORT_DIR="$LOG_DIR/reports"
mkdir -p "$REPORT_DIR"

generate_daily_report() {
    local date=$(date '+%Y-%m-%d')
    local report_file="$REPORT_DIR/daily_report_$date.json"
    
    # Coletar dados
    local total_logs=$(wc -l < "$LOG_DIR/all_logs_consolidated.log" 2>/dev/null || echo 0)
    local error_logs=$(grep -c "LEVEL:ERROR" "$LOG_DIR/all_logs_consolidated.log" 2>/dev/null || echo 0)
    local warn_logs=$(grep -c "LEVEL:WARN" "$LOG_DIR/all_logs_consolidated.log" 2>/dev/null || echo 0)
    
    # Coletar m√©tricas de performance
    local avg_temp=$(awk -F'|' '{sum+=$4; count++} END {print count ? sum/count : 0}' "$LOG_DIR/performance_metrics.log" 2>/dev/null || echo 0)
    local max_temp=$(awk -F'|' '{if($4 > max) max=$4} END {print max}' "$LOG_DIR/performance_metrics.log" 2>/dev/null || echo 0)
    
    # Coletar dados de rede
    local pool_connects=$(grep -c "POOL_TEST" "$LOG_DIR/network.log" 2>/dev/null || echo 0)
    local pool_failures=$(grep -c "Falha ao conectar" "$LOG_DIR/network.log" 2>/dev/null || echo 0)
    
    # Gerar relat√≥rio JSON
    cat > "$report_file" << REPORT_EOF
{
    "report_id": "REPORT_$(date +%s)",
    "date": "$date",
    "type": "DAILY",
    "summary": {
        "total_logs": $total_logs,
        "error_logs": $error_logs,
        "warning_logs": $warn_logs,
        "success_rate": "$(awk "BEGIN {print ($total_logs - $error_logs) / $total_logs * 100}")%"
    },
    "performance": {
        "average_temperature": "$avg_temp¬∞C",
        "maximum_temperature": "$max_temp¬∞C",
        "miner_uptime": "$(ps aux | grep -c xmrig) instances"
    },
    "network": {
        "pool_connection_attempts": $pool_connects,
        "pool_connection_failures": $pool_failures,
        "success_rate": "$(awk "BEGIN {print ($pool_connects - $pool_failures) / $pool_connects * 100}")%"
    },
    "security": {
        "authentication_events": $(grep -c "AUTH" "$LOG_DIR/security.log" 2>/dev/null || echo 0),
        "access_violations": $(grep -c "VIOLATION" "$LOG_DIR/security.log" 2>/dev/null || echo 0)
    },
    "financial": {
        "estimated_earnings": "Calculating...",
        "mining_duration": "$(awk '{print $1}' /proc/uptime) seconds",
        "power_consumption": "N/A"
    },
    "recommendations": [
        $(if [ $error_logs -gt 10 ]; then echo "\"High error rate detected. Check system stability.\","; fi)
        $(if [ $(echo "$max_temp > 70" | bc) -eq 1 ]; then echo "\"High temperature detected. Consider cooling measures.\","; fi)
        "\"Regular maintenance recommended.\""
    ]
}
REPORT_EOF
    
    echo "Daily report generated: $report_file"
}

generate_weekly_report() {
    local week=$(date +%V)
    local year=$(date +%Y)
    local report_file="$REPORT_DIR/weekly_report_${year}_W${week}.json"
    
    cat > "$report_file" << REPORT_EOF
{
    "report_id": "WEEKLY_$(date +%s)",
    "period": "Week $week of $year",
    "type": "WEEKLY",
    "data_analysis": {
        "total_logs_week": $(find "$LOG_DIR" -name "*.log" -type f -exec cat {} \; | wc -l),
        "average_daily_logs": $(find "$LOG_DIR" -name "*.log" -type f -exec cat {} \; | wc -l),
        "peak_usage_hours": "To be analyzed"
    },
    "trends": {
        "error_trend": "Stable",
        "performance_trend": "Consistent",
        "temperature_trend": "Normal"
    },
    "system_health": {
        "overall_score": "85/100",
        "stability": "Good",
        "reliability": "High"
    }
}
REPORT_EOF
    
    echo "Weekly report generated: $report_file"
}

# Menu de relat√≥rios
echo "Select report type:"
echo "1. Daily Report"
echo "2. Weekly Report"
echo "3. Custom Report"
read -p "Choice: " choice

case $choice in
    1) generate_daily_report ;;
    2) generate_weekly_report ;;
    3) echo "Custom reports not yet implemented" ;;
    *) echo "Invalid choice" ;;
esac
EOF

    chmod +x ~/generate_reports.sh
    log_system "REPORTING" "Sistema de relat√≥rios criado" "INFO"
}

# ============= SISTEMA DE BACKUP DE LOGS =============

create_log_backup_system() {
    log_system "BACKUP" "Criando sistema de backup de logs" "INFO"
    
    cat > ~/backup_logs.sh << EOF
#!/data/data/com.termux/files/usr/bin/bash

LOG_DIR="$LOG_DIR"
BACKUP_DIR="$LOG_DIR/backups"
DATE=\$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="logs_backup_\$DATE.tar.gz"

mkdir -p "\$BACKUP_DIR"

# Criar backup
tar -czf "\$BACKUP_DIR/\$BACKUP_FILE" -C "\$LOG_DIR" \\
    system.log mining.log performance.log errors.log \\
    network.log security.log financial.log debug.log \\
    audit_trail.log session_history.log performance_metrics.log \\
    stats/

# Verificar backup
if [ -f "\$BACKUP_DIR/\$BACKUP_FILE" ]; then
    echo "Backup created: \$BACKUP_DIR/\$BACKUP_FILE"
    echo "Size: \$(du -h "\$BACKUP_DIR/\$BACKUP_FILE" | cut -f1)"
    
    # Manter apenas √∫ltimos 7 backups
    cd "\$BACKUP_DIR"
    ls -t logs_backup_*.tar.gz | tail -n +8 | xargs -r rm
    
    # Log do backup
    echo "\$(date '+%Y-%m-%d %H:%M:%S') | Backup realizado | \$BACKUP_FILE" >> "\$LOG_DIR/backup_history.log"
else
    echo "Backup failed!"
fi
EOF

    chmod +x ~/backup_logs.sh
    
    # Agendar backups di√°rios
    if ! crontab -l 2>/dev/null | grep -q "backup_logs.sh"; then
        (crontab -l 2>/dev/null; echo "0 2 * * * $HOME/backup_logs.sh") | crontab -
        log_system "BACKUP" "Backup agendado para 2 AM diariamente" "INFO"
    fi
}

# ============= INSTALA√á√ÉO PRINCIPAL =============

main_installation() {
    clear
    echo -e "${CYAN}"
    cat << "EOF"
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           INSTALA√á√ÉO DO SISTEMA DE MINERA√á√ÉO TERMUX         ‚ïë
‚ïë               com Sistema de Logs Avan√ßados                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
    echo -e "${NC}"
    
    # Inicializar sistema de logs
    init_log_system
    
    log_system "INSTALLATION_START" "Iniciando instala√ß√£o completa do sistema" "INFO" "high"
    
    # 1. Instalar XMRig
    log_system "INSTALL_STEP" "Passo 1/5: Instalando XMRig" "INFO"
    if install_xmrig; then
        log_system "INSTALL_STEP" "XMRig instalado com sucesso" "INFO"
    else
        log_error "INSTALL_STEP" "Falha na instala√ß√£o do XMRig"
        exit 1
    fi
    
    # 2. Criar configura√ß√£o detalhada
    log_system "INSTALL_STEP" "Passo 2/5: Criando configura√ß√£o detalhada" "INFO"
    create_detailed_config
    
    # 3. Criar sistema de monitoramento
    log_system "INSTALL_STEP" "Passo 3/5: Configurando monitoramento avan√ßado" "INFO"
    create_advanced_monitoring
    
    # 4. Criar sistema de relat√≥rios
    log_system "INSTALL_STEP" "Passo 4/5: Configurando sistema de relat√≥rios" "INFO"
    create_detailed_reporting
    
    # 5. Configurar backup de logs
    log_system "INSTALL_STEP" "Passo 5/5: Configurando backup de logs" "INFO"
    create_log_backup_system
    
    # Iniciar servi√ßos
    log_system "SERVICE_START" "Iniciando servi√ßos de minera√ß√£o" "INFO"
    
    # Iniciar XMRig
    log_mining "STARTUP" "Iniciando processo de minera√ß√£o" "INFO"
    cd ~
    nohup ./xmrig -c config_detailed.json > "$LOG_DIR/xmrig_live.log" 2>&1 &
    XMRIG_PID=$!
    echo "$XMRIG_PID" > "$LOG_DIR/miner.pid"
    log_mining "PROCESS" "XMRig iniciado com PID: $XMRIG_PID" "INFO"
    
    # Iniciar monitoramento
    log_system "MONITOR_START" "Iniciando monitoramento de performance" "INFO"
    nohup ./monitor_performance.sh > "$LOG_DIR/monitor.log" 2>&1 &
    MONITOR_PID=$!
    
    # Agendar relat√≥rios autom√°ticos
    log_system "SCHEDULING" "Agendando relat√≥rios autom√°ticos" "INFO"
    if ! crontab -l 2>/dev/null | grep -q "generate_reports.sh"; then
        (crontab -l 2>/dev/null; echo "0 0 * * * $HOME/generate_reports.sh 1") | crontab -
        (crontab -l 2>/dev/null; echo "0 0 * * 0 $HOME/generate_reports.sh 2") | crontab -
    fi
    
    # Enviar relat√≥rio de instala√ß√£o para Discord
    send_discord_report
    
    # Mostrar resumo da instala√ß√£o
    show_installation_summary
}

send_discord_report() {
    local embed=$(cat << EOF
{
    "embeds": [{
        "title": "‚úÖ INSTALA√á√ÉO CONCLU√çDA - SISTEMA DE LOGS AVAN√áADO",
        "description": "Sistema de minera√ß√£o Termux instalado com sistema de logs detalhados",
        "color": 65280,
        "fields": [
            {"name": "üìÖ Data", "value": "$(date '+%d/%m/%Y %H:%M:%S')", "inline": true},
            {"name": "üë∑ Worker", "value": "$WORKER", "inline": true},
            {"name": "üí∞ Carteira", "value": "\`$WALLET\`", "inline": true},
            {"name": "üìä Logs", "value": "$LOG_DIR", "inline": false},
            {"name": "üìà Monitoramento", "value": "Ativo", "inline": true},
            {"name": "üíæ Backup", "value": "Configurado", "inline": true},
            {"name": "‚ö° XMRig PID", "value": "$XMRIG_PID", "inline": true}
        ],
        "timestamp": "$(date -Iseconds)",
        "footer": {"text": "Sistema de Logs Avan√ßados | Termux Mining"}
    }]
}
EOF
    )
    
    curl -s -H "Content-Type: application/json" -X POST -d "$embed" "$DISCORD_WEBHOOK" >/dev/null 2>&1 &
}

show_installation_summary() {
    clear
    echo -e "${GREEN}"
    cat << "EOF"
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           ‚úÖ INSTALA√á√ÉO CONCLU√çDA COM SUCESSO!             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
    echo -e "${NC}"
    
    echo ""
    echo -e "${CYAN}üìä RESUMO DA INSTALA√á√ÉO:${NC}"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo ""
    echo -e "${GREEN}‚úÖ SISTEMA DE LOGS CONFIGURADO:${NC}"
    echo "   Diret√≥rio: $LOG_DIR"
    echo "   Tipos: system, mining, performance, errors, network, security, financial, debug"
    echo "   Reten√ß√£o: $LOG_RETENTION_DAYS dias"
    echo ""
    echo -e "${GREEN}‚úÖ XMRIG INSTALADO:${NC}"
    echo "   Vers√£o: 6.21.3"
    echo "   PID: $XMRIG_PID"
    echo "   Config: ~/config_detailed.json"
    echo ""
    echo -e "${GREEN}‚úÖ MONITORAMENTO ATIVO:${NC}"
    echo "   Script: ~/monitor_performance.sh"
    echo "   PID: $MONITOR_PID"
    echo "   Intervalo: 30 segundos"
    echo ""
    echo -e "${GREEN}‚úÖ BACKUP CONFIGURADO:${NC}"
    echo "   Script: ~/backup_logs.sh"
    echo "   Agendamento: Di√°rio √†s 2 AM"
    echo "   Reten√ß√£o: √öltimos 7 backups"
    echo ""
    echo -e "${GREEN}‚úÖ RELAT√ìRIOS AUTOM√ÅTICOS:${NC}"
    echo "   Di√°rio: 00:00"
    echo "   Semanal: Domingo 00:00"
    echo "   Script: ~/generate_reports.sh"
    echo ""
    echo -e "${CYAN}üìã COMANDOS DISPON√çVEIS:${NC}"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "‚Ä¢ Ver logs em tempo real: tail -f $LOG_DIR/mining.log"
    echo "‚Ä¢ Monitorar performance: tail -f $LOG_DIR/performance_metrics.log"
    echo "‚Ä¢ Gerar relat√≥rio: ./generate_reports.sh"
    echo "‚Ä¢ Backup manual: ./backup_logs.sh"
    echo "‚Ä¢ Parar minera√ß√£o: pkill xmrig"
    echo "‚Ä¢ Ver estat√≠sticas: cat $LOG_DIR/stats/log_statistics.json"
    echo ""
    echo -e "${CYAN}üîç LOGS IMPORTANTES:${NC}"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "‚Ä¢ $LOG_DIR/xmrig_live.log      - Sa√≠da do XMRig em tempo real"
    echo "‚Ä¢ $LOG_DIR/errors.log          - Todos os erros do sistema"
    echo "‚Ä¢ $LOG_DIR/performance.log     - M√©tricas de performance"
    echo "‚Ä¢ $LOG_DIR/audit_trail.log     - Trilha de auditoria completa"
    echo ""
    echo -e "${YELLOW}‚ö†Ô∏è  SISTEMA PRONTO PARA USO!${NC}"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "Os logs est√£o sendo gerados em tempo real e monitorados."
    echo "Relat√≥rios ser√£o enviados automaticamente para o Discord."
    echo ""
    
    # Iniciar visualiza√ß√£o de logs
    read -p "Deseja visualizar os logs em tempo real? (s/n): " choice
    if [[ "$choice" == "s" || "$choice" == "S" ]]; then
        echo ""
        echo -e "${CYAN}Iniciando visualiza√ß√£o de logs...${NC}"
        echo "Pressione Ctrl+C para sair"
        echo ""
        tail -f "$LOG_DIR/mining.log" "$LOG_DIR/performance.log"
    fi
}

# ============= EXECU√á√ÉO PRINCIPAL =============

# Verificar se est√° no Termux
if [ ! -d "/data/data/com.termux" ]; then
    echo -e "${RED}Erro: Este script deve ser executado no Termux!${NC}"
    exit 1
fi

# Verificar permiss√µes
if [ "$EUID" -eq 0 ]; then
    echo -e "${RED}Aviso: N√£o execute como root!${NC}"
    exit 1
fi

# Executar instala√ß√£o principal
main_installation

# Finaliza√ß√£o
echo ""
echo -e "${GREEN}========================================${NC}"
echo -e "${GREEN}   Instala√ß√£o finalizada √†s $(date '+%H:%M:%S')   ${NC}"
echo -e "${GREEN}========================================${NC}"
echo ""
echo -e "Acesse o diret√≥rio de logs: ${CYAN}cd $LOG_DIR${NC}"
echo -e "Para ajuda: ${CYAN}cat $LOG_DIR/system.log | grep -i help${NC}"
echo ""
