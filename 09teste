#!/data/data/com.termux/files/usr/bin/bash

# ====================================================
# SISTEMA DE MINERA√á√ÉO NICEHASH - TERMUX
# ====================================================

# CONFIGURA√á√ïES DA NICEHASH (OBRIGAT√ìRIAS)
NICEHASH_API_KEY="7d8889ce-0391-4f65-bf9d-bce2c696a6ef"
NICEHASH_API_SECRET="30050e97-a129-4c74-bd52-8c36fc365fe80def10b"
NICEHASH_ORG_ID="5c88fb09-353c-42f4-adbb-433787cd8077"
NICEHASH_WALLET="bc1qtz2j3ky2nh409w432wh8uyqphhny84a3qhs2tl"

# CONFIGURA√á√ïES DE MINERA√á√ÉO
POOL_HOST="sha256.usa.nicehash.com"
POOL_PORT="3334"
WORKER_NAME="termux_miner"
ALGORITHM="sha256"
THREADS=2

# CONFIGURA√á√ïES DISCORD
DISCORD_WEBHOOK="https://discord.com/api/webhooks/1470009252063088661/1j4kNu2sDcGQmFCywnbd_p1BEbb1DTcN_VXt5OYpX8_FsQI2YKB3tCjS2Okp_msUX9Mh"

# DIRET√ìRIOS
BASE_DIR="$HOME/.nicehash_auto"
LOG_DIR="$BASE_DIR/logs"
MINER_DIR="$BASE_DIR/miner"
PID_FILE="$BASE_DIR/miner.pid"
CONFIG_FILE="$BASE_DIR/config.json"

# CORES (para output no terminal)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m'

# FUN√á√ÉO DE LOG
log() {
    local message="$1"
    local color="$2"
    echo -e "${color}[$(date '+%Y-%m-%d %H:%M:%S')] ${message}${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $message" >> "$LOG_DIR/system.log"
}

# INICIALIZA√á√ÉO
init() {
    # Criar diret√≥rios
    mkdir -p "$BASE_DIR" "$LOG_DIR" "$MINER_DIR"
    
    log "=== INICIANDO SISTEMA DE MINERA√á√ÉO NICEHASH ===" "$PURPLE"
    
    # Verificar se estamos no Termux
    if [ ! -d "/data/data/com.termux" ]; then
        log "ERRO: Este script deve ser executado no Termux!" "$RED"
        exit 1
    fi
    
    # Atualizar pacotes
    log "Atualizando pacotes..." "$CYAN"
    pkg update -y > /dev/null 2>&1
    pkg upgrade -y > /dev/null 2>&1
    
    # Instalar depend√™ncias
    log "Instalando depend√™ncias..." "$CYAN"
    pkg install -y git wget curl proot build-essential automake autoconf pkg-config libcurl4-openssl-dev libjansson-dev libssl-dev libgmp-dev zlib1g-dev > /dev/null 2>&1
    
    # Verificar API Key
    if [ -z "$NICEHASH_API_KEY" ] || [ "$NICEHASH_API_KEY" = "SUA_API_KEY_AQUI" ]; then
        log "ERRO: Configure sua API Key da NiceHash no script!" "$RED"
        exit 1
    fi
    
    log "API Key configurada: ${NICEHASH_API_KEY:0:12}..." "$GREEN"
    log "Carteira: ${NICEHASH_WALLET:0:12}..." "$GREEN"
    
    # Instalar minerador
    install_miner
    
    # Configurar minerador
    setup_config
    
    # Iniciar minera√ß√£o
    start_mining
}

# INSTALAR MINERADOR
install_miner() {
    log "Verificando minerador..." "$CYAN"
    
    # Se j√° existe, n√£o instala novamente
    if [ -f "$MINER_DIR/cpuminer" ]; then
        log "Minerador j√° instalado." "$GREEN"
        return 0
    fi
    
    cd "$MINER_DIR"
    
    # Tentar baixar vers√£o pr√©-compilada
    log "Baixando minerador..." "$CYAN"
    if wget -q https://github.com/tpruvot/cpuminer-multi/releases/download/v2.5.1/cpuminer-multi-arm64-2.5.1.tar.gz; then
        tar -xzf cpuminer-multi-arm64-2.5.1.tar.gz
        mv cpuminer-multi-arm64/cpuminer ./cpuminer
        chmod +x cpuminer
        log "Minerador baixado com sucesso!" "$GREEN"
        return 0
    fi
    
    # Fallback: compilar a partir do c√≥digo fonte
    log "Compilando minerador a partir do c√≥digo fonte..." "$YELLOW"
    git clone https://github.com/tpruvot/cpuminer-multi > /dev/null 2>&1
    cd cpuminer-multi
    ./build.sh > /dev/null 2>&1
    ./autogen.sh > /dev/null 2>&1
    ./configure CFLAGS="-march=native" > /dev/null 2>&1
    make -j2 > /dev/null 2>&1
    
    if [ -f "cpuminer" ]; then
        cp cpuminer "$MINER_DIR/"
        chmod +x "$MINER_DIR/cpuminer"
        log "Minerador compilado com sucesso!" "$GREEN"
    else
        log "ERRO: Falha ao instalar minerador." "$RED"
        exit 1
    fi
}

# CONFIGURAR ARQUIVO DE CONFIGURA√á√ÉO
setup_config() {
    cat > "$CONFIG_FILE" << EOF
{
    "api_key": "$NICEHASH_API_KEY",
    "api_secret": "$NICEHASH_API_SECRET",
    "org_id": "$NICEHASH_ORG_ID",
    "wallet": "$NICEHASH_WALLET",
    "pool_host": "$POOL_HOST",
    "pool_port": "$POOL_PORT",
    "worker": "$WORKER_NAME",
    "algorithm": "$ALGORITHM",
    "threads": $THREADS,
    "discord_webhook": "$DISCORD_WEBHOOK",
    "start_time": "$(date -Iseconds)"
}
EOF
    log "Configura√ß√£o salva em: $CONFIG_FILE" "$GREEN"
}

# INICIAR MINERA√á√ÉO
start_mining() {
    log "Iniciando minera√ß√£o..." "$PURPLE"
    
    # Parar minera√ß√£o anterior se existir
    if [ -f "$PID_FILE" ]; then
        local old_pid=$(cat "$PID_FILE")
        kill -9 "$old_pid" 2>/dev/null
        rm -f "$PID_FILE"
    fi
    
    cd "$MINER_DIR"
    
    # Criar script de execu√ß√£o cont√≠nua
    cat > "$MINER_DIR/run.sh" << EOF
#!/data/data/com.termux/files/usr/bin/bash
cd "$MINER_DIR"
while true; do
    ./cpuminer -a $ALGORITHM \\
        -o stratum+tcp://$POOL_HOST:$POOL_PORT \\
        -u $NICEHASH_API_KEY.$WORKER_NAME \\
        -p x \\
        -t $THREADS \\
        --quiet \\
        --retry-pause=10
    sleep 5
done
EOF
    
    chmod +x "$MINER_DIR/run.sh"
    
    # Executar em background
    nohup "$MINER_DIR/run.sh" > "$LOG_DIR/miner.log" 2>&1 &
    
    local miner_pid=$!
    echo $miner_pid > "$PID_FILE"
    
    log "Minerador iniciado (PID: $miner_pid)" "$GREEN"
    log "Logs do minerador: $LOG_DIR/miner.log" "$CYAN"
    
    # Enviar notifica√ß√£o de in√≠cio para o Discord
    send_discord_notification "üöÄ **MINERA√á√ÉO INICIADA**" "Sistema NiceHash ativado no Termux\n\n**Worker:** $WORKER_NAME\n**Pool:** $POOL_HOST:$POOL_PORT\n**Threads:** $THREADS\n**Hora:** $(date '+%H:%M:%S')" 3066993
    
    # Iniciar monitoramento
    start_monitoring
}

# MONITORAMENTO
start_monitoring() {
    log "Iniciando sistema de monitoramento..." "$CYAN"
    
    # Executar monitoramento em background
    (
        while true; do
            sleep 60
            
            # Verificar se o minerador ainda est√° rodando
            if [ ! -f "$PID_FILE" ]; then
                log "Arquivo PID n√£o encontrado. Reiniciando minerador..." "$YELLOW" >> "$LOG_DIR/monitor.log"
                restart_miner
                continue
            fi
            
            local pid=$(cat "$PID_FILE" 2>/dev/null)
            if [ -z "$pid" ] || ! kill -0 "$pid" 2>/dev/null; then
                log "Minerador n√£o est√° respondendo. Reiniciando..." "$YELLOW" >> "$LOG_DIR/monitor.log"
                restart_miner
            fi
            
            # Verificar temperatura a cada 5 minutos
            if [ $(( $(date +%s) % 300 )) -eq 0 ]; then
                check_temperature
            fi
            
            # Verificar ganhos via API a cada 30 minutos
            if [ $(( $(date +%s) % 1800 )) -eq 0 ]; then
                check_earnings
            fi
            
            # Enviar status a cada hora
            if [ $(( $(date +%s) % 3600 )) -eq 0 ]; then
                send_status_update
            fi
        done
    ) &
    
    log "Monitoramento ativado" "$GREEN"
    
    # Mostrar status inicial
    show_status
}

# REINICIAR MINERADOR
restart_miner() {
    log "Reiniciando minerador..." "$YELLOW" >> "$LOG_DIR/monitor.log"
    
    # Parar processo atual
    if [ -f "$PID_FILE" ]; then
        kill $(cat "$PID_FILE") 2>/dev/null
        rm -f "$PID_FILE"
        sleep 5
    fi
    
    # Iniciar novamente
    cd "$MINER_DIR"
    nohup "$MINER_DIR/run.sh" > "$LOG_DIR/miner.log" 2>&1 &
    
    local new_pid=$!
    echo $new_pid > "$PID_FILE"
    
    log "Minerador reiniciado (PID: $new_pid)" "$GREEN" >> "$LOG_DIR/monitor.log"
}

# VERIFICAR TEMPERATURA
check_temperature() {
    local temp
    if [ -f "/sys/class/thermal/thermal_zone0/temp" ]; then
        temp=$(($(cat /sys/class/thermal/thermal_zone0/temp) / 1000))
        
        if [ $temp -gt 70 ]; then
            log "ALERTA: Temperatura elevada: ${temp}¬∞C" "$RED" >> "$LOG_DIR/temp.log"
            
            # Reduzir threads se temperatura muito alta
            if [ $temp -gt 80 ] && [ $THREADS -gt 1 ]; then
                THREADS=$((THREADS - 1))
                log "Reduzindo threads para $THREADS devido √† temperatura" "$YELLOW" >> "$LOG_DIR/temp.log"
                send_discord_notification "üå°Ô∏è **ALERTA DE TEMPERATURA**" "Temperatura: ${temp}¬∞C\nThreads reduzidas para: $THREADS" 15158332
                restart_miner
            elif [ $temp -gt 70 ]; then
                send_discord_notification "üå°Ô∏è **TEMPERATURA ALTA**" "Temperatura atual: ${temp}¬∞C\nMonitorando..." 16776960
            fi
        fi
    fi
}

# VERIFICAR GANHOS VIA API
check_earnings() {
    log "Verificando ganhos na NiceHash..." "$CYAN" >> "$LOG_DIR/earnings.log"
    
    local timestamp=$(date +%s)000000000
    local nonce=$(cat /proc/sys/kernel/random/uuid)
    local org_id="$NICEHASH_ORG_ID"
    
    # Gerar assinatura
    local message="${NICEHASH_API_KEY}${timestamp}${org_id}"
    local signature=$(echo -n "$message" | openssl sha256 -hmac "$NICEHASH_API_SECRET" 2>/dev/null | cut -d' ' -f2)
    
    if [ -z "$signature" ]; then
        log "N√£o foi poss√≠vel gerar assinatura para API" "$YELLOW" >> "$LOG_DIR/earnings.log"
        return 1
    fi
    
    # Fazer requisi√ß√£o √† API
    local response=$(curl -s -w "\n%{http_code}" \
        -H "X-Time: $timestamp" \
        -H "X-Nonce: $nonce" \
        -H "X-Organization-Id: $org_id" \
        -H "X-Auth: ${NICEHASH_API_KEY}:${signature}" \
        "https://api2.nicehash.com/api/v2/mining/rigs2")
    
    local http_code=$(echo "$response" | tail -1)
    local json_response=$(echo "$response" | sed '$d')
    
    if [ "$http_code" = "200" ]; then
        # Extrair saldo n√£o pago
        local unpaid=$(echo "$json_response" | jq -r '.totalUnpaidAmount' 2>/dev/null)
        
        if [ -n "$unpaid" ] && [ "$unpaid" != "null" ]; then
            log "Saldo n√£o pago: $unpaid BTC" "$GREEN" >> "$LOG_DIR/earnings.log"
            
            # Converter para satoshis
            local satoshis=$(echo "scale=0; $unpaid * 100000000" | bc | cut -d. -f1)
            
            # Enviar notifica√ß√£o se houver saldo significativo
            if [ $(echo "$unpaid > 0.00001" | bc -l) -eq 1 ]; then
                send_discord_notification "üí∞ **GANHOS ATUALIZADOS**" "Saldo n√£o pago: $unpaid BTC\nSatoshis: $satoshis sats\n\nAcesse: https://www.nicehash.com/my/wallets" 15844367
            fi
            
            # Registrar no arquivo de hist√≥rico
            echo "$(date '+%Y-%m-%d %H:%M:%S'),$unpaid,$satoshis" >> "$LOG_DIR/balance_history.csv"
        fi
    else
        log "Erro na API NiceHash: HTTP $http_code" "$RED" >> "$LOG_DIR/earnings.log"
    fi
}

# ENVIAR ATUALIZA√á√ÉO DE STATUS
send_status_update() {
    local uptime=$(uptime -p | sed 's/up //')
    local temp=$(get_temperature)
    
    send_discord_notification "üìä **STATUS DO SISTEMA**" "**Tempo de atividade:** $uptime\n**Temperatura:** ${temp}¬∞C\n**Worker:** $WORKER_NAME\n**Threads:** $THREADS\n**√öltima verifica√ß√£o:** $(date '+%H:%M:%S')" 3447003
}

# ENVIAR NOTIFICA√á√ÉO PARA DISCORD
send_discord_notification() {
    local title="$1"
    local description="$2"
    local color="$3"
    
    local json_data=$(cat << EOF
{
    "embeds": [
        {
            "title": "$title",
            "description": "$description",
            "color": $color,
            "timestamp": "$(date -Iseconds)",
            "footer": {
                "text": "NiceHash Miner ‚Ä¢ $(date '+%d/%m/%Y')"
            }
        }
    ]
}
EOF
    )
    
    curl -s -H "Content-Type: application/json" -X POST -d "$json_data" "$DISCORD_WEBHOOK" > /dev/null 2>&1 &
}

# MOSTRAR STATUS
show_status() {
    clear
    echo -e "${PURPLE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${PURPLE}‚ïë               SISTEMA DE MINERA√á√ÉO NICEHASH                 ‚ïë${NC}"
    echo -e "${PURPLE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
    echo -e "${GREEN}‚úÖ Sistema inicializado com sucesso!${NC}"
    echo ""
    echo -e "${CYAN}üìä INFORMA√á√ïES:${NC}"
    echo -e "   üîë  API Key: ${NICEHASH_API_KEY:0:12}..."
    echo -e "   üë∑  Worker: $WORKER_NAME"
    echo -e "   üîó  Pool: $POOL_HOST:$POOL_PORT"
    echo -e "   üßµ  Threads: $THREADS"
    echo ""
    echo -e "${YELLOW}üìÅ ARQUIVOS E LOGS:${NC}"
    echo -e "   üìÑ  Logs do sistema: $LOG_DIR/system.log"
    echo -e "   ‚öôÔ∏è   Configura√ß√£o: $CONFIG_FILE"
    echo -e "   üí∞  Hist√≥rico de ganhos: $LOG_DIR/balance_history.csv"
    echo ""
    echo -e "${BLUE}üîß STATUS:${NC}"
    echo -e "   üü¢  Minera√ß√£o: ATIVA"
    echo -e "   üì°  Monitoramento: ATIVO"
    echo -e "   üì®  Notifica√ß√µes: ATIVAS"
    echo ""
    echo -e "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${WHITE}‚è∞  Iniciado em: $(date '+%H:%M:%S')${NC}"
    echo -e "${WHITE}üì±  O sistema continuar√° rodando em segundo plano${NC}"
    echo ""
    echo -e "${RED}‚ö†Ô∏è   PARA PARAR A MINERA√á√ÉO:${NC}"
    echo -e "   pkill -f cpuminer"
    echo -e "   rm -f $PID_FILE"
    echo ""
    echo -e "${CYAN}üìã  PARA VERIFICAR LOGS EM TEMPO REAL:${NC}"
    echo -e "   tail -f $LOG_DIR/miner.log"
    echo ""
    
    # Mostrar √∫ltimas linhas do log do minerador
    if [ -f "$LOG_DIR/miner.log" ]; then
        echo -e "${GREEN}üìÑ √öltimas linhas do minerador:${NC}"
        tail -5 "$LOG_DIR/miner.log" | while read line; do
            echo "   $line"
        done
    fi
    
    echo ""
    
    # Manter a exibi√ß√£o por 30 segundos, depois sair silenciosamente
    for i in {30..1}; do
        echo -ne "${YELLOW}‚è≥  O sistema continuar√° em background em $i segundos...${NC}\r"
        sleep 1
    done
    echo -e "\n${GREEN}‚úÖ  Continuando em background...${NC}"
    
    # Sair do script, deixando os processos em background
    exit 0
}

# OBTER TEMPERATURA
get_temperature() {
    if [ -f "/sys/class/thermal/thermal_zone0/temp" ]; then
        echo $(($(cat /sys/class/thermal/thermal_zone0/temp) / 1000))
    else
        echo "N/A"
    fi
}

# TRATAMENTO DE SINAIS
cleanup() {
    log "Recebido sinal de desligamento. Parando minera√ß√£o..." "$YELLOW"
    
    # Parar minerador
    if [ -f "$PID_FILE" ]; then
        kill $(cat "$PID_FILE") 2>/dev/null
        rm -f "$PID_FILE"
    fi
    
    # Enviar notifica√ß√£o de parada
    send_discord_notification "üõë **MINERA√á√ÉO PARADA**" "Sistema encerrado\nHora: $(date '+%H:%M:%S')" 15158332
    
    log "Sistema parado com sucesso" "$GREEN"
    exit 0
}

trap cleanup SIGINT SIGTERM

# EXECU√á√ÉO PRINCIPAL
init

# Este ponto n√£o deve ser alcan√ßado, pois o init chama show_status que termina com exit 0
# Mas mantemos um loop infinito por seguran√ßa
while true; do
    sleep 3600
done
