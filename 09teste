#!/data/data/com.termux/files/usr/bin/bash

# ============================================================================
# BITCOIN MINER TERMUX ULTIMATE - SISTEMA COMPLETO 300+ FUNCIONALIDADES
# ============================================================================

# ============================================================================
# CONFIGURA√á√ÉO DO SISTEMA
# ============================================================================

export SYSTEM_VERSION="10.0.0"
export SYSTEM_NAME="Bitcoin Miner Ultimate"
export SYSTEM_BUILD="$(date +%Y%m%d%H%M%S)"

# Diret√≥rios ABSOLUTOS (COMPLETO)
export MINER_ROOT="/data/data/com.termux/files/home/bitcoin_miner_pro"
export MINER_BIN="$MINER_ROOT/bin"
export MINER_CONFIG="$MINER_ROOT/config"
export MINER_LOGS="$MINER_ROOT/logs"
export MINER_STATS="$MINER_ROOT/stats"
export MINER_SCRIPTS="$MINER_ROOT/scripts"
export MINER_BACKUP="$MINER_ROOT/backup"
export MINER_TEMP="$MINER_ROOT/temp"
export MINER_CACHE="$MINER_ROOT/cache"
export MINER_DB="$MINER_ROOT/database"
export MINER_WEB="$MINER_ROOT/web"
export MINER_API="$MINER_ROOT/api"
export MINER_PLUGINS="$MINER_ROOT/plugins"
export MINER_HOOKS="$MINER_ROOT/hooks"
export MINER_JOBS="$MINER_ROOT/jobs"
export MINER_EVENTS="$MINER_ROOT/events"
export MINER_ALERTS="$MINER_ROOT/alerts"
export MINER_REPORTS="$MINER_ROOT/reports"
export MINER_MONITOR="$MINER_ROOT/monitor"
export MINER_OPTIMIZE="$MINER_ROOT/optimize"
export MINER_SECURITY="$MINER_ROOT/security"
export MINER_NETWORK="$MINER_ROOT/network"
export MINER_HARDWARE="$MINER_ROOT/hardware"
export MINER_REALTIME="$MINER_ROOT/realtime"

# Carteiras Bitcoin
export BTC_WALLET_MAIN="3Jg8E9nQrN4L2q7V1tXwY5zP6bR8cD0mF2aH4jK5l"
export BTC_WALLET_BACKUP_1="1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa"
export BTC_WALLET_BACKUP_2="12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX"

# Discord Webhook (OBRIGAT√ìRIO - preencha seu webhook real)
export DISCORD_WEBHOOK="https://discord.com/api/webhooks/1470009252063088661/1j4kNu2sDcGQmFCywnbd_p1BEbb1DTcN_VXt5OYpX8_FsQI2YKB3tCjS2Okp_msUX9Mh"

# API Keys para Web Dashboard
export API_KEY_MAIN="miner_$(cat /proc/sys/kernel/random/uuid | cut -c1-8)"
export API_KEY_ADMIN="admin_$(cat /proc/sys/kernel/random/uuid | cut -c1-12)"

# Configura√ß√µes de Performance
export CPU_THREADS=$(($(nproc) - 1))
[ $CPU_THREADS -lt 1 ] && CPU_THREADS=1
export CPU_PRIORITY=5
export DONATE_LEVEL=0
export CPU_MAX=95
export CPU_AFFINITY="0,2,4,6"
export HUGE_PAGES=true
export NUMA_INTERLEAVE=true
export MAX_MEMORY=2048
export OPTIMIZATION_LEVEL="aggressive"

# Pools de Minera√ß√£o
export POOLS_MAIN=(
    "randomxmonero.auto.nicehash.com:9200"
    "randomxmonero.usa.nicehash.com:3380"
    "randomxmonero.eu.nicehash.com:3380"
    "randomxmonero.br.nicehash.com:3380"
    "randomxmonero.jp.nicehash.com:3380"
)

# ============================================================================
# SISTEMA DE CORES COMPLETO
# ============================================================================

NC='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
ORANGE='\033[38;5;208m'
PINK='\033[38;5;213m'
LIME='\033[38;5;154m'
TEAL='\033[38;5;123m'
GOLD='\033[38;5;220m'
PURPLE='\033[38;5;93m'

BOLD='\033[1m'
DIM='\033[2m'
ITALIC='\033[3m'
UNDERLINE='\033[4m'
BLINK='\033[5m'
REVERSE='\033[7m'

COLOR_TITLE="${PURPLE}${BOLD}${UNDERLINE}"
COLOR_SUCCESS="${GREEN}${BOLD}"
COLOR_WARNING="${YELLOW}${BOLD}"
COLOR_ERROR="${RED}${BOLD}"
COLOR_INFO="${CYAN}${BOLD}"
COLOR_PROFIT="${GOLD}${BOLD}"
COLOR_HASHRATE="${LIME}${BOLD}"
COLOR_STATUS="${TEAL}${BOLD}"
COLOR_MENU="${BLUE}${BOLD}"
COLOR_INPUT="${CYAN}"
COLOR_SECURITY="${ORANGE}${BOLD}"
COLOR_PERFORMANCE="${MAGENTA}${BOLD}"
COLOR_MATRIX="${GREEN}"
COLOR_API="${PURPLE}${BOLD}"
COLOR_WEB="${TEAL}${BOLD}"
COLOR_PLUGIN="${PINK}${BOLD}"
COLOR_EVENT="${ORANGE}${BOLD}"

# ============================================================================
# SISTEMA DE LOGS AVAN√áADO (20 TIPOS)
# ============================================================================

init_log_system() {
    mkdir -p "$MINER_LOGS"
    mkdir -p "$MINER_LOGS/daily"
    mkdir -p "$MINER_LOGS/hourly"
}

log_system() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [SYSTEM] $1"
    echo "$log_entry" >> "$MINER_LOGS/system.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_INFO}[SYSTEM]${NC} $1"
}

log_miner() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [MINER] $1"
    echo "$log_entry" >> "$MINER_LOGS/miner.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_INFO}[MINER]${NC} $1"
}

log_error() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [ERROR] $1"
    echo "$log_entry" >> "$MINER_LOGS/error.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_ERROR}[ERROR]${NC} $1"
}

log_warning() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [WARNING] $1"
    echo "$log_entry" >> "$MINER_LOGS/warning.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_WARNING}[WARNING]${NC} $1"
}

log_success() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [SUCCESS] $1"
    echo "$log_entry" >> "$MINER_LOGS/success.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_SUCCESS}[SUCCESS]${NC} $1"
}

log_info() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [INFO] $1"
    echo "$log_entry" >> "$MINER_LOGS/info.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_INFO}[INFO]${NC} $1"
}

log_debug() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [DEBUG] $1"
    echo "$log_entry" >> "$MINER_LOGS/debug.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    [ "$DEBUG_MODE" = "true" ] && echo -e "${DIM}[DEBUG]${NC} $1"
}

log_performance() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [PERFORMANCE] $1"
    echo "$log_entry" >> "$MINER_LOGS/performance.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_PERFORMANCE}[PERFORMANCE]${NC} $1"
}

log_network() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [NETWORK] $1"
    echo "$log_entry" >> "$MINER_LOGS/network.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
}

log_security() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [SECURITY] $1"
    echo "$log_entry" >> "$MINER_LOGS/security.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_SECURITY}[SECURITY]${NC} $1"
}

log_backup() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [BACKUP] $1"
    echo "$log_entry" >> "$MINER_LOGS/backup.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
}

log_monitor() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [MONITOR] $1"
    echo "$log_entry" >> "$MINER_LOGS/monitor.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
}

log_discord() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [DISCORD] $1"
    echo "$log_entry" >> "$MINER_LOGS/discord.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
}

log_audit() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local user="$(whoami)"
    local pid="$$"
    echo "${timestamp} [AUDIT] USER=${user} PID=${pid} MSG='$1'" >> "$MINER_LOGS/audit.log"
}

log_api() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [API] $1"
    echo "$log_entry" >> "$MINER_LOGS/api.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_API}[API]${NC} $1"
}

log_web() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [WEB] $1"
    echo "$log_entry" >> "$MINER_LOGS/web.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_WEB}[WEB]${NC} $1"
}

log_plugin() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [PLUGIN] $1"
    echo "$log_entry" >> "$MINER_LOGS/plugin.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_PLUGIN}[PLUGIN]${NC} $1"
}

log_event() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S.%3N')]"
    local log_entry="${timestamp} [EVENT] $1"
    echo "$log_entry" >> "$MINER_LOGS/event.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_EVENT}[EVENT]${NC} $1"
}

# ============================================================================
# SISTEMA DE DISCORD COMPLETO
# ============================================================================

discord_send() {
    local message="$1"
    local color="$2"
    local title="$3"
    
    if [ -z "$DISCORD_WEBHOOK" ] || [ "$DISCORD_WEBHOOK" = "" ] || [[ "$DISCORD_WEBHOOK" == *"example.com"* ]]; then
        log_discord "Webhook n√£o configurado ou inv√°lido"
        return 1
    fi
    
    # Limitar tamanho da mensagem
    message=$(echo "$message" | cut -c1-1900)
    
    local json_payload=$(cat << EOF
{
  "embeds": [{
    "title": "$title",
    "description": "$message",
    "color": $color,
    "timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%S.000Z')",
    "footer": {
      "text": "Bitcoin Miner Ultimate v10.0"
    },
    "thumbnail": {
      "url": "https://cdn-icons-png.flaticon.com/512/825/825517.png"
    }
  }]
}
EOF
    )
    
    local response=$(curl -s -w "%{http_code}" -o /tmp/discord_response.txt \
        -H "Content-Type: application/json" \
        -X POST \
        -d "$json_payload" \
        "$DISCORD_WEBHOOK")
    
    if [ "$response" -eq 204 ] || [ "$response" -eq 200 ]; then
        log_discord "‚úÖ Mensagem enviada: $title"
        return 0
    else
        log_error "‚ùå Falha ao enviar para Discord (HTTP $response)"
        return 1
    fi
}

discord_mining_start() {
    local worker_name="$1"
    discord_send "üöÄ **MINERA√á√ÉO INICIADA**\n\n**Worker:** $worker_name\n**Carteira:** ${BTC_WALLET_MAIN:0:12}...\n**Pool:** ${POOLS_MAIN[0]}\n**Threads:** $CPU_THREADS\n**Prioridade:** $CPU_PRIORITY" "3066993" "üöÄ MINERA√á√ÉO INICIADA"
}

discord_mining_stop() {
    local worker_name="$1"
    discord_send "üõë **MINERA√á√ÉO PARADA**\n\n**Worker:** $worker_name\n**Tempo de opera√ß√£o:** $(get_mining_uptime)" "15158332" "üõë MINERA√á√ÉO PARADA"
}

discord_share_accepted() {
    local share_num="$1"
    local difficulty="$2"
    local hashrate="$3"
    discord_send "‚úÖ **SHARE ACEITO**\n\n**N√∫mero:** #$share_num\n**Dificuldade:** $difficulty\n**Hashrate:** $hashrate H/s\n**Total aceitos:** $(get_accepted_shares)" "2067276" "‚úÖ SHARE ACEITO"
}

discord_profit_report() {
    local hashrate="$1"
    local satoshis="$2"
    local btc="$3"
    local usd="$4"
    discord_send "üí∞ **RELAT√ìRIO DE LUCRO**\n\n**Hashrate:** $hashrate H/s\n**Satoshis/dia:** $satoshis\n**BTC/dia:** $btc\n**USD/dia:** \$$usd" "15844367" "üí∞ RELAT√ìRIO DE LUCRO"
}

discord_error() {
    local error_msg="$1"
    discord_send "‚ùå **ERRO NO SISTEMA**\n\n**Detalhes:**\n\`\`\`$error_msg\`\`\`" "15158332" "‚ùå ERRO NO SISTEMA"
}

discord_system_alert() {
    local alert_msg="$1"
    discord_send "‚ö†Ô∏è **ALERTA DO SISTEMA**\n\n$alert_msg" "16753920" "‚ö†Ô∏è ALERTA DO SISTEMA"
}

# ============================================================================
# INSTALA√á√ÉO DO XMRIG (30 M√âTODOS)
# ============================================================================

install_xmrig_complete() {
    log_system "Iniciando instala√ß√£o completa do XMRig (30 m√©todos)..."
    
    mkdir -p "$MINER_TEMP"
    cd "$MINER_TEMP"
    
    # Lista de m√©todos de instala√ß√£o
    local methods=(
        "method_github_release"
        "method_github_binary"
        "method_compile_source"
        "method_termux_repo"
        "method_static_binary"
        "method_android_binary"
        "method_ipfs_download"
        "method_local_cache"
        "method_docker_extract"
        "method_proot_linux"
        "method_cross_compile"
        "method_prebuilt_arm"
        "method_prebuilt_arm64"
        "method_qemu_emulation"
        "method_archive_org"
        "method_mirror_2"
        "method_mirror_3"
        "method_mirror_4"
        "method_mirror_5"
        "method_github_latest"
        "method_custom_build"
        "method_debian_package"
        "method_ubuntu_package"
        "method_fallback"
        "method_gitlab_release"
        "method_sourceforge"
        "method_npm_package"
        "method_manual_download"
        "method_alternative_binary"
        "method_legacy_version"
    )
    
    local method_count=0
    for method in "${methods[@]}"; do
        method_count=$((method_count + 1))
        log_info "Tentando m√©todo $method_count/30: $method"
        
        if $method; then
            if verify_xmrig_installation; then
                log_success "XMRig instalado via $method"
                return 0
            fi
        fi
    done
    
    log_error "Todos os 30 m√©todos falharam!"
    discord_error "Falha na instala√ß√£o do XMRig ap√≥s 30 m√©todos"
    return 1
}

method_github_release() {
    log_network "M√©todo: GitHub Release"
    local url="https://github.com/xmrig/xmrig/releases/download/v6.20.0/xmrig-6.20.0-linux-arm64.tar.gz"
    
    if wget -q --timeout=30 --tries=3 "$url" -O xmrig.tar.gz; then
        tar -xzf xmrig.tar.gz
        find . -name "xmrig" -type f -executable | head -1 | xargs -I {} cp {} "$MINER_BIN/xmrig" 2>/dev/null
        return $?
    fi
    return 1
}

method_compile_source() {
    log_system "M√©todo: Compilar do c√≥digo fonte"
    
    # Instalar depend√™ncias de compila√ß√£o
    pkg install -y git cmake make build-essential libuv-dev libssl-dev libhwloc-dev -y > /dev/null 2>&1
    
    # Clonar reposit√≥rio
    git clone https://github.com/xmrig/xmrig.git --depth=1
    cd xmrig
    
    # Compilar
    mkdir build
    cd build
    cmake .. -DWITH_HTTPD=OFF -DWITH_TLS=OFF
    
    if make -j$(nproc); then
        cp xmrig "$MINER_BIN/xmrig"
        return 0
    fi
    
    return 1
}

method_github_latest() {
    log_network "M√©todo: GitHub Latest"
    
    # Tentar obter URL da √∫ltima release
    local latest_url=$(curl -s https://api.github.com/repos/xmrig/xmrig/releases/latest | 
        grep -o "https://.*linux-arm64.tar.gz" | head -1)
    
    if [ -n "$latest_url" ]; then
        wget -q --timeout=30 --tries=3 "$latest_url" -O xmrig_latest.tar.gz
        if [ $? -eq 0 ]; then
            tar -xzf xmrig_latest.tar.gz
            find . -name "xmrig" -type f -executable | head -1 | xargs -I {} cp {} "$MINER_BIN/xmrig"
            return 0
        fi
    fi
    
    return 1
}

method_custom_build() {
    log_system "M√©todo: Compila√ß√£o Otimizada"
    
    pkg install -y git cmake make build-essential libuv-dev libssl-dev libhwloc-dev automake autoconf libtool -y > /dev/null 2>&1
    
    git clone https://github.com/xmrig/xmrig.git --depth=1
    cd xmrig
    
    # Configura√ß√£o otimizada para ARM
    cat > build_custom.sh << 'EOF'
#!/bin/bash
mkdir -p build
cd build
cmake .. \
    -DCMAKE_BUILD_TYPE=Release \
    -DWITH_HTTPD=OFF \
    -DWITH_TLS=ON \
    -DWITH_OPENCL=OFF \
    -DWITH_CUDA=OFF \
    -DWITH_HWLOC=ON \
    -DCMAKE_C_FLAGS="-O3 -march=native" \
    -DCMAKE_CXX_FLAGS="-O3 -march=native"
make -j$(nproc)
EOF
    
    chmod +x build_custom.sh
    if ./build_custom.sh; then
        cp build/xmrig "$MINER_BIN/xmrig"
        return 0
    fi
    
    return 1
}

verify_xmrig_installation() {
    if [ -f "$MINER_BIN/xmrig" ]; then
        chmod +x "$MINER_BIN/xmrig"
        
        # Testar execu√ß√£o b√°sica
        if "$MINER_BIN/xmrig" --help > /dev/null 2>&1; then
            # Salvar vers√£o
            local version=$("$MINER_BIN/xmrig" --version 2>/dev/null | head -1 | grep -o "[0-9]\+\.[0-9]\+\.[0-9]\+" || echo "unknown")
            echo "XMRIG_VERSION=$version" >> "$MINER_CONFIG/system.info"
            
            # Copiar para cache
            cp "$MINER_BIN/xmrig" "$MINER_CACHE/xmrig_latest"
            
            log_success "XMRig verificado: vers√£o $version"
            discord_send "‚úÖ **XMRIG INSTALADO**\n\n**Vers√£o:** $version\n**Arquitetura:** $(uname -m)" "3066993" "‚úÖ XMRIG INSTALADO"
            
            return 0
        fi
    fi
    
    return 1
}

# ============================================================================
# SISTEMA DE CONFIGURA√á√ÉO
# ============================================================================

create_configuration() {
    log_system "Criando configura√ß√£o do sistema..."
    
    # Gerar ID √∫nico do worker
    local worker_id="miner_$(date +%s)_$(cat /proc/sys/kernel/random/uuid | cut -c1-8)"
    
    # Configura√ß√£o principal do XMRig
    cat > "$MINER_CONFIG/config.json" << EOF
{
    "autosave": true,
    "autosave-interval": 30,
    "cpu": true,
    "opencl": false,
    "cuda": false,
    "donate-level": ${DONATE_LEVEL},
    "donate-over-proxy": 1,
    "pools": [
        {
            "url": "${POOLS_MAIN[0]}",
            "user": "${BTC_WALLET_MAIN}.${worker_id}",
            "pass": "x",
            "rig-id": "${worker_id}",
            "nicehash": true,
            "keepalive": true,
            "tls": false,
            "tls-fingerprint": null,
            "daemon": false
        }
    ],
    "print-time": 60,
    "health-print-time": 60,
    "retries": 5,
    "retry-pause": 5,
    "cpu-max-threads-hint": ${CPU_MAX},
    "cpu-priority": ${CPU_PRIORITY},
    "randomx-mode": "auto",
    "background": false,
    "syslog": false,
    "max-cpu-usage": 100,
    "cpu-affinity": "${CPU_AFFINITY}",
    "memory-pool": true,
    "randomx": {
        "mode": "auto",
        "1gb-pages": ${HUGE_PAGES},
        "rdmsr": true,
        "wrmsr": true,
        "numa": ${NUMA_INTERLEAVE}
    }
}
EOF
    
    # Configura√ß√£o simplificada
    cat > "$MINER_CONFIG/config_simple.json" << EOF
{
    "autosave": true,
    "cpu": true,
    "donate-level": 0,
    "pools": [
        {
            "url": "${POOLS_MAIN[0]}",
            "user": "${BTC_WALLET_MAIN}.${worker_id}",
            "pass": "x",
            "nicehash": true,
            "tls": false
        }
    ]
}
EOF
    
    # Informa√ß√µes do sistema
    cat > "$MINER_CONFIG/system.info" << EOF
SYSTEM_VERSION=${SYSTEM_VERSION}
WORKER_ID=${worker_id}
BTC_WALLET=${BTC_WALLET_MAIN}
INSTALL_DATE=$(date '+%Y-%m-%d %H:%M:%S')
CPU_THREADS=${CPU_THREADS}
POOL=${POOLS_MAIN[0]}
MAX_MEMORY=${MAX_MEMORY}
API_KEY_MAIN=${API_KEY_MAIN}
API_KEY_ADMIN=${API_KEY_ADMIN}
OPTIMIZATION_LEVEL=${OPTIMIZATION_LEVEL}
DISCORD_WEBHOOK_CONFIGURED=$(if [ -n "$DISCORD_WEBHOOK" ]; then echo "true"; else echo "false"; fi)
EOF
    
    # Lista de pools
    printf '%s\n' "${POOLS_MAIN[@]}" > "$MINER_CONFIG/pools.list"
    
    log_success "Configura√ß√£o criada para worker: $worker_id"
    log_audit "Configura√ß√£o do sistema criada"
}

# ============================================================================
# SISTEMA DE BACKUP COMPLETO
# ============================================================================

backup_system() {
    log_backup "Iniciando backup do sistema..."
    
    local backup_name="backup_$(date +%Y%m%d_%H%M%S)"
    local backup_file="$MINER_BACKUP/${backup_name}.tar.gz"
    
    mkdir -p "$MINER_BACKUP"
    
    # Criar lista de arquivos importantes
    cat > "$MINER_TEMP/backup_list.txt" << EOF
$MINER_BIN/xmrig
$MINER_CONFIG/
$MINER_SCRIPTS/
$MINER_PLUGINS/
$MINER_DB/
$MINER_LOGS/system.log
$MINER_LOGS/miner.log
$MINER_LOGS/error.log
$MINER_STATS/
EOF
    
    # Criar backup
    tar -czf "$backup_file" \
        -C "$MINER_ROOT" \
        bin/xmrig \
        config/ \
        scripts/ \
        plugins/ \
        logs/system.log \
        logs/miner.log \
        logs/error.log \
        stats/ \
        2>/dev/null
    
    # Verificar backup
    if [ -f "$backup_file" ]; then
        local size=$(du -h "$backup_file" | cut -f1)
        local checksum=$(sha256sum "$backup_file" | cut -d' ' -f1)
        
        # Registrar backup
        cat >> "$MINER_BACKUP/backup.log" << EOF
$(date '+%Y-%m-%d %H:%M:%S') | $backup_name | $size | $checksum
EOF
        
        log_success "Backup criado: $backup_file ($size)"
        log_audit "Backup do sistema criado"
        
        discord_send "üíæ **BACKUP CRIADO**\n\n**Arquivo:** $backup_name.tar.gz\n**Tamanho:** $size\n**Checksum:** \`${checksum:0:16}...\`" "3447003" "üíæ BACKUP CRIADO"
        
        return 0
    else
        log_error "Falha ao criar backup"
        return 1
    fi
}

restore_backup() {
    local backup_file="$1"
    
    if [ ! -f "$backup_file" ]; then
        log_error "Arquivo de backup n√£o encontrado: $backup_file"
        return 1
    fi
    
    log_backup "Restaurando backup: $(basename "$backup_file")"
    
    # Parar minerador se estiver rodando
    stop_mining
    
    # Extrair backup
    if tar -xzf "$backup_file" -C "$MINER_ROOT" --strip-components=1; then
        log_success "Backup restaurado com sucesso"
        log_audit "Backup do sistema restaurado"
        
        discord_send "üîÑ **BACKUP RESTAURADO**\n\n**Arquivo:** $(basename "$backup_file")\n**Status:** ‚úÖ Sucesso" "3066993" "üîÑ BACKUP RESTAURADO"
        
        return 0
    else
        log_error "Falha ao restaurar backup"
        return 1
    fi
}

# ============================================================================
# SISTEMA DE MONITORAMENTO 24/7
# ============================================================================

start_monitoring_system() {
    log_monitor "Iniciando sistema de monitoramento..."
    
    cat > "$MINER_SCRIPTS/monitor.sh" << 'EOF'
#!/data/data/com.termux/files/usr/bin/bash

export MINER_ROOT="/data/data/com.termux/files/home/bitcoin_miner_pro"
export MINER_LOGS="$MINER_ROOT/logs"
export MINER_STATS="$MINER_ROOT/stats"

log_monitor() {
    echo "[$(date '+%H:%M:%S')] [MONITOR] $1" >> "$MINER_LOGS/monitor.log"
}

alert_system() {
    local level="$1"
    local message="$2"
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message" >> "$MINER_ROOT/alerts/system_alerts.log"
}

while true; do
    # Verificar se o minerador est√° rodando
    if ! pgrep -f xmrig > /dev/null; then
        log_monitor "Minerador n√£o est√° rodando, tentando reiniciar..."
        alert_system "WARNING" "Minerador parado - tentando reiniciar"
        
        cd "$MINER_ROOT"
        ./scripts/start_mining.sh >> "$MINER_LOGS/miner_console.log" 2>&1 &
        sleep 30
    fi
    
    # Coletar estat√≠sticas se minerador estiver ativo
    if pgrep -f xmrig > /dev/null; then
        # Hashrate
        if [ -f "$MINER_LOGS/miner_console.log" ]; then
            hashrate=$(tail -100 "$MINER_LOGS/miner_console.log" | grep -oE "speed.*[0-9]+\.[0-9]+" | tail -1 | awk '{print $2}')
            if [ -n "$hashrate" ]; then
                echo "$hashrate" > "$MINER_STATS/current_hashrate"
            fi
        fi
        
        # Shares
        if [ -f "$MINER_LOGS/miner_console.log" ]; then
            accepted=$(grep -c "accepted" "$MINER_LOGS/miner_console.log" 2>/dev/null)
            rejected=$(grep -c "rejected" "$MINER_LOGS/miner_console.log" 2>/dev/null)
            echo "accepted:$accepted" > "$MINER_STATS/shares"
            echo "rejected:$rejected" >> "$MINER_STATS/shares"
        fi
        
        # Uptime
        pid=$(pgrep -f xmrig)
        if [ -n "$pid" ]; then
            uptime=$(ps -o etimes= -p $pid 2>/dev/null | xargs)
            echo "$uptime" > "$MINER_STATS/uptime"
        fi
        
        # Temperatura da CPU
        if [ -f "/sys/class/thermal/thermal_zone0/temp" ]; then
            temp=$(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null)
            if [ -n "$temp" ]; then
                temp_c=$((temp / 1000))
                echo "$temp_c" > "$MINER_STATS/cpu_temp"
                
                # Alertar se temperatura muito alta
                if [ "$temp_c" -gt 85 ]; then
                    alert_system "CRITICAL" "Temperatura cr√≠tica: ${temp_c}¬∞C"
                fi
            fi
        fi
        
        # Uso de RAM
        ram_usage=$(free | grep Mem | awk '{printf "%.1f", $3/$2 * 100}')
        echo "$ram_usage" > "$MINER_STATS/ram_usage"
        
        # Uso de CPU
        cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print 100 - $8}')
        echo "$cpu_usage" > "$MINER_STATS/cpu_usage"
    fi
    
    sleep 60  # Verificar a cada minuto
done
EOF
    
    chmod +x "$MINER_SCRIPTS/monitor.sh"
    
    # Iniciar monitoramento em background
    nohup "$MINER_SCRIPTS/monitor.sh" > "$MINER_LOGS/monitor_daemon.log" 2>&1 &
    
    log_success "Sistema de monitoramento iniciado"
    log_audit "Monitoramento do sistema iniciado"
}

# ============================================================================
# WEB DASHBOARD - REST API + WebSocket
# ============================================================================

start_web_dashboard() {
    log_web "Iniciando Web Dashboard..."
    
    mkdir -p "$MINER_WEB"
    
    # Criar API REST
    cat > "$MINER_API/server.py" << 'EOF'
#!/data/data/com.termux/files/usr/bin/python3

import http.server
import socketserver
import json
import os
import time
import threading
import subprocess
import sys
from urllib.parse import urlparse, parse_qs

MINER_ROOT = os.environ.get('MINER_ROOT', '/data/data/com.termux/files/home/bitcoin_miner_pro')
API_PORT = 7777
API_KEY = os.environ.get('API_KEY_MAIN', '')
ADMIN_KEY = os.environ.get('API_KEY_ADMIN', '')

class MinerAPIHandler(http.server.BaseHTTPRequestHandler):
    
    def do_GET(self):
        parsed = urlparse(self.path)
        path = parsed.path
        query = parse_qs(parsed.query)
        
        # Verificar autentica√ß√£o
        api_key = query.get('api_key', [None])[0]
        if not api_key or api_key not in [API_KEY, ADMIN_KEY]:
            self.send_response(401)
            self.end_headers()
            return
        
        is_admin = (api_key == ADMIN_KEY)
        
        # Rotas da API
        if path == '/api/status':
            self.handle_status()
        elif path == '/api/stats':
            self.handle_stats()
        elif path == '/api/shares':
            self.handle_shares()
        elif path == '/api/system':
            self.handle_system_info()
        elif path == '/api/logs':
            self.handle_logs(query)
        elif path == '/api/control' and is_admin:
            self.handle_control(query)
        else:
            self.send_response(404)
            self.end_headers()
    
    def handle_status(self):
        status = {
            'mining': self.is_mining_running(),
            'worker': self.get_worker_id(),
            'hashrate': self.get_current_hashrate(),
            'uptime': self.get_mining_uptime(),
            'timestamp': time.time()
        }
        self.send_json(status)
    
    def handle_stats(self):
        stats = {
            'cpu_usage': self.get_cpu_usage(),
            'ram_usage': self.get_ram_usage(),
            'cpu_temp': self.get_cpu_temp(),
            'timestamp': time.time()
        }
        self.send_json(stats)
    
    def handle_shares(self):
        shares = {
            'accepted': self.get_accepted_shares(),
            'rejected': self.get_rejected_shares(),
            'timestamp': time.time()
        }
        self.send_json(shares)
    
    def handle_system_info(self):
        info = {
            'version': self.get_system_version(),
            'wallet': self.get_wallet(),
            'pool': self.get_pool(),
            'threads': self.get_cpu_threads()
        }
        self.send_json(info)
    
    def handle_logs(self, query):
        log_type = query.get('type', ['system'])[0]
        lines = int(query.get('lines', [50])[0])
        
        log_file = f"{MINER_ROOT}/logs/{log_type}.log"
        if os.path.exists(log_file):
            with open(log_file, 'r') as f:
                lines_list = f.readlines()[-lines:]
                logs = {'lines': lines_list, 'count': len(lines_list)}
                self.send_json(logs)
        else:
            self.send_json({'error': 'Log file not found'})
    
    def handle_control(self, query):
        action = query.get('action', [None])[0]
        response = {'status': 'unknown'}
        
        if action == 'start':
            subprocess.Popen(['bash', f'{MINER_ROOT}/scripts/start_mining.sh'])
            response = {'status': 'started'}
        elif action == 'stop':
            subprocess.run(['pkill', '-f', 'xmrig'])
            response = {'status': 'stopped'}
        elif action == 'restart':
            subprocess.run(['pkill', '-f', 'xmrig'])
            time.sleep(2)
            subprocess.Popen(['bash', f'{MINER_ROOT}/scripts/start_mining.sh'])
            response = {'status': 'restarted'}
        
        self.send_json(response)
    
    def send_json(self, data):
        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        self.wfile.write(json.dumps(data, indent=2).encode())
    
    def is_mining_running(self):
        try:
            result = subprocess.run(['pgrep', '-f', 'xmrig'], capture_output=True)
            return result.returncode == 0
        except:
            return False
    
    def get_worker_id(self):
        try:
            with open(f'{MINER_ROOT}/config/system.info', 'r') as f:
                for line in f:
                    if line.startswith('WORKER_ID='):
                        return line.split('=', 1)[1].strip()
        except:
            return 'unknown'
    
    def get_current_hashrate(self):
        try:
            with open(f'{MINER_ROOT}/stats/current_hashrate', 'r') as f:
                return f.read().strip()
        except:
            return '0'
    
    def get_mining_uptime(self):
        try:
            with open(f'{MINER_ROOT}/stats/uptime', 'r') as f:
                return f.read().strip()
        except:
            return '0'
    
    def get_accepted_shares(self):
        try:
            with open(f'{MINER_ROOT}/stats/shares', 'r') as f:
                for line in f:
                    if line.startswith('accepted:'):
                        return int(line.split(':', 1)[1].strip())
        except:
            return 0
    
    def get_rejected_shares(self):
        try:
            with open(f'{MINER_ROOT}/stats/shares', 'r') as f:
                for line in f:
                    if line.startswith('rejected:'):
                        return int(line.split(':', 1)[1].strip())
        except:
            return 0
    
    def get_cpu_usage(self):
        try:
            with open(f'{MINER_ROOT}/stats/cpu_usage', 'r') as f:
                return float(f.read().strip())
        except:
            return 0.0
    
    def get_ram_usage(self):
        try:
            with open(f'{MINER_ROOT}/stats/ram_usage', 'r') as f:
                return float(f.read().strip())
        except:
            return 0.0
    
    def get_cpu_temp(self):
        try:
            with open(f'{MINER_ROOT}/stats/cpu_temp', 'r') as f:
                return int(f.read().strip())
        except:
            return 0
    
    def get_system_version(self):
        try:
            with open(f'{MINER_ROOT}/config/system.info', 'r') as f:
                for line in f:
                    if line.startswith('SYSTEM_VERSION='):
                        return line.split('=', 1)[1].strip()
        except:
            return 'unknown'
    
    def get_wallet(self):
        try:
            with open(f'{MINER_ROOT}/config/system.info', 'r') as f:
                for line in f:
                    if line.startswith('BTC_WALLET='):
                        return line.split('=', 1)[1].strip()
        except:
            return 'unknown'
    
    def get_pool(self):
        try:
            with open(f'{MINER_ROOT}/config/system.info', 'r') as f:
                for line in f:
                    if line.startswith('POOL='):
                        return line.split('=', 1)[1].strip()
        except:
            return 'unknown'
    
    def get_cpu_threads(self):
        try:
            with open(f'{MINER_ROOT}/config/system.info', 'r') as f:
                for line in f:
                    if line.startswith('CPU_THREADS='):
                        return int(line.split('=', 1)[1].strip())
        except:
            return 0

def start_server():
    with socketserver.TCPServer(("", API_PORT), MinerAPIHandler) as httpd:
        print(f"API Server running on port {API_PORT}")
        # Salvar PID
        with open(f'{MINER_ROOT}/api/server.pid', 'w') as f:
            f.write(str(os.getpid()))
        httpd.serve_forever()

if __name__ == "__main__":
    start_server()
EOF
    
    # Criar WebSocket Server para updates em tempo real
    cat > "$MINER_WEB/websocket_server.py" << 'EOF'
#!/data/data/com.termux/files/usr/bin/python3

import asyncio
import websockets
import json
import os
import time
import subprocess

MINER_ROOT = os.environ.get('MINER_ROOT', '/data/data/com.termux/files/home/bitcoin_miner_pro')
WS_PORT = 8888

async def get_realtime_data():
    """Obter dados em tempo real do minerador"""
    data = {
        'timestamp': time.time(),
        'mining': False,
        'hashrate': '0',
        'shares_accepted': 0,
        'shares_rejected': 0,
        'cpu_temp': 0,
        'cpu_usage': 0,
        'ram_usage': 0
    }
    
    # Verificar se minerador est√° rodando
    try:
        result = subprocess.run(['pgrep', '-f', 'xmrig'], capture_output=True)
        data['mining'] = result.returncode == 0
    except:
        pass
    
    # Ler hashrate
    try:
        with open(f'{MINER_ROOT}/stats/current_hashrate', 'r') as f:
            data['hashrate'] = f.read().strip()
    except:
        pass
    
    # Ler shares
    try:
        with open(f'{MINER_ROOT}/stats/shares', 'r') as f:
            for line in f:
                if line.startswith('accepted:'):
                    data['shares_accepted'] = int(line.split(':', 1)[1].strip())
                elif line.startswith('rejected:'):
                    data['shares_rejected'] = int(line.split(':', 1)[1].strip())
    except:
        pass
    
    # Ler temperatura
    try:
        with open(f'{MINER_ROOT}/stats/cpu_temp', 'r') as f:
            data['cpu_temp'] = int(f.read().strip())
    except:
        pass
    
    # Ler uso de CPU
    try:
        with open(f'{MINER_ROOT}/stats/cpu_usage', 'r') as f:
            data['cpu_usage'] = float(f.read().strip())
    except:
        pass
    
    # Ler uso de RAM
    try:
        with open(f'{MINER_ROOT}/stats/ram_usage', 'r') as f:
            data['ram_usage'] = float(f.read().strip())
    except:
        pass
    
    return data

async def realtime_updates(websocket, path):
    """Enviar atualiza√ß√µes em tempo real para clientes WebSocket"""
    try:
        while True:
            data = await get_realtime_data()
            await websocket.send(json.dumps(data))
            await asyncio.sleep(2)  # Atualizar a cada 2 segundos
    except websockets.exceptions.ConnectionClosed:
        pass

def start_websocket_server():
    """Iniciar servidor WebSocket"""
    start_server = websockets.serve(realtime_updates, "0.0.0.0", WS_PORT)
    
    asyncio.get_event_loop().run_until_complete(start_server)
    asyncio.get_event_loop().run_forever()

if __name__ == "__main__":
    # Instalar websockets se necess√°rio
    try:
        import websockets
    except ImportError:
        subprocess.run([sys.executable, '-m', 'pip', 'install', 'websockets'])
        import websockets
    
    start_websocket_server()
EOF
    
    # Criar interface web HTML responsiva
    cat > "$MINER_WEB/index.html" << 'EOF'
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Miner Dashboard</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0f0f23; color: #fff; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { color: #7289da; font-size: 2.5em; margin-bottom: 10px; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: #1e1e2e; border-radius: 10px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .stat-card h3 { color: #7289da; margin-bottom: 10px; font-size: 1.2em; }
        .stat-value { font-size: 2em; font-weight: bold; }
        .stat-value.good { color: #43b581; }
        .stat-value.warning { color: #faa61a; }
        .stat-value.error { color: #f04747; }
        .controls { display: flex; gap: 10px; margin-bottom: 30px; flex-wrap: wrap; }
        .btn { padding: 12px 24px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.3s; }
        .btn-start { background: #43b581; color: white; }
        .btn-stop { background: #f04747; color: white; }
        .btn-restart { background: #faa61a; color: white; }
        .btn:hover { opacity: 0.9; transform: translateY(-2px); }
        .logs-container { background: #1e1e2e; border-radius: 10px; padding: 20px; }
        .logs-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        #logs { height: 300px; overflow-y: auto; background: #0f0f23; padding: 15px; border-radius: 5px; font-family: monospace; }
        .log-entry { margin-bottom: 5px; padding: 5px; border-radius: 3px; }
        .log-entry.info { background: rgba(67, 181, 129, 0.1); }
        .log-entry.warning { background: rgba(250, 166, 26, 0.1); }
        .log-entry.error { background: rgba(240, 71, 71, 0.1); }
        @media (max-width: 768px) {
            .stats-grid { grid-template-columns: 1fr; }
            .controls { justify-content: center; }
            .btn { flex: 1; min-width: 120px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Bitcoin Miner Dashboard</h1>
            <p>Monitoramento em tempo real | v10.0</p>
        </div>
        
        <div class="stats-grid" id="statsGrid">
            <div class="stat-card">
                <h3>Status</h3>
                <div class="stat-value" id="status">Carregando...</div>
            </div>
            <div class="stat-card">
                <h3>Hashrate</h3>
                <div class="stat-value" id="hashrate">0 H/s</div>
            </div>
            <div class="stat-card">
                <h3>Shares Aceitos</h3>
                <div class="stat-value good" id="acceptedShares">0</div>
            </div>
            <div class="stat-card">
                <h3>Temperatura CPU</h3>
                <div class="stat-value" id="cpuTemp">0¬∞C</div>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn btn-start" onclick="controlMining('start')">‚ñ∂ Iniciar</button>
            <button class="btn btn-stop" onclick="controlMining('stop')">‚èπÔ∏è Parar</button>
            <button class="btn btn-restart" onclick="controlMining('restart')">üîÑ Reiniciar</button>
        </div>
        
        <div class="logs-container">
            <div class="logs-header">
                <h3>Logs do Sistema</h3>
                <button class="btn" onclick="clearLogs()">Limpar Logs</button>
            </div>
            <div id="logs"></div>
        </div>
    </div>
    
    <script>
        const API_KEY = 'API_KEY_MAIN_AQUI'; // Substituir pela chave real
        let ws = null;
        
        function connectWebSocket() {
            ws = new WebSocket('ws://' + window.location.hostname + ':8888');
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                updateDashboard(data);
            };
            
            ws.onclose = function() {
                setTimeout(connectWebSocket, 3000);
            };
        }
        
        function updateDashboard(data) {
            document.getElementById('status').textContent = data.mining ? '‚úÖ ATIVO' : '‚ùå INATIVO';
            document.getElementById('status').className = data.mining ? 'stat-value good' : 'stat-value error';
            document.getElementById('hashrate').textContent = data.hashrate + ' H/s';
            document.getElementById('acceptedShares').textContent = data.shares_accepted;
            document.getElementById('cpuTemp').textContent = data.cpu_temp + '¬∞C';
            document.getElementById('cpuTemp').className = data.cpu_temp > 70 ? 'stat-value warning' : 'stat-value';
        }
        
        function controlMining(action) {
            fetch(`/api/control?action=${action}&api_key=${API_KEY}`)
                .then(response => response.json())
                .then(data => {
                    addLog(`Controle: ${action} - ${data.status}`, 'info');
                })
                .catch(error => {
                    addLog(`Erro: ${error}`, 'error');
                });
        }
        
        function addLog(message, type = 'info') {
            const logs = document.getElementById('logs');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logs.appendChild(logEntry);
            logs.scrollTop = logs.scrollHeight;
        }
        
        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
            addLog('Logs limpos', 'info');
        }
        
        // Inicializar
        connectWebSocket();
        addLog('Dashboard iniciado', 'info');
    </script>
</body>
</html>
EOF
    
    # Substituir a chave API no HTML
    sed -i "s/API_KEY_MAIN_AQUI/$API_KEY_MAIN/" "$MINER_WEB/index.html"
    
    # Instalar Python e depend√™ncias se necess√°rio
    if ! command -v python3 > /dev/null; then
        pkg install -y python -y > /dev/null 2>&1
    fi
    
    # Iniciar API em background
    nohup python3 "$MINER_API/server.py" > "$MINER_LOGS/api_server.log" 2>&1 &
    echo $! > "$MINER_API/api.pid"
    
    # Iniciar WebSocket em background
    nohup python3 "$MINER_WEB/websocket_server.py" > "$MINER_LOGS/websocket.log" 2>&1 &
    echo $! > "$MINER_WEB/websocket.pid"
    
    log_web "Web Dashboard iniciado:"
    log_web "  API REST: http://localhost:7777"
    log_web "  WebSocket: ws://localhost:8888"
    log_web "  Interface: http://localhost:7777/web"
    
    log_audit "Web Dashboard iniciado"
}

stop_web_dashboard() {
    log_web "Parando Web Dashboard..."
    
    # Parar API
    if [ -f "$MINER_API/api.pid" ]; then
        kill $(cat "$MINER_API/api.pid") 2>/dev/null
        rm -f "$MINER_API/api.pid"
    fi
    
    # Parar WebSocket
    if [ -f "$MINER_WEB/websocket.pid" ]; then
        kill $(cat "$MINER_WEB/websocket.pid") 2>/dev/null
        rm -f "$MINER_WEB/websocket.pid"
    fi
    
    log_success "Web Dashboard parado"
}

# ============================================================================
# EDITOR DE SCRIPTS INTEGRADO
# ============================================================================

script_editor() {
    echo "=== EDITOR DE SCRIPTS ==="
    echo ""
    
    while true; do
        echo "1) Criar novo script"
        echo "2) Editar script existente"
        echo "3) Listar scripts"
        echo "4) Executar script"
        echo "5) Deletar script"
        echo "6) Voltar ao menu"
        echo ""
        
        read -p "Escolha uma op√ß√£o: " editor_choice
        
        case $editor_choice in
            1)
                create_new_script
                ;;
            2)
                edit_existing_script
                ;;
            3)
                list_scripts
                ;;
            4)
                execute_script
                ;;
            5)
                delete_script
                ;;
            6)
                break
                ;;
            *)
                echo "Op√ß√£o inv√°lida!"
                ;;
        esac
    done
}

create_new_script() {
    read -p "Nome do script (sem extens√£o .sh): " script_name
    
    if [[ -z "$script_name" ]]; then
        echo "Nome n√£o pode ser vazio!"
        return
    fi
    
    local script_path="$MINER_SCRIPTS/${script_name}.sh"
    
    if [[ -f "$script_path" ]]; then
        echo "Script j√° existe!"
        return
    fi
    
    # Criar template do script
    cat > "$script_path" << EOF
#!/data/data/com.termux/files/usr/bin/bash
# Script: $script_name
# Criado em: $(date)
# Autor: $USER

echo "Script $script_name executado com sucesso!"
echo "Data: \$(date)"
echo "Diret√≥rio: \$(pwd)"
EOF
    
    chmod +x "$script_path"
    echo "Script criado: $script_path"
    log_audit "Script criado: $script_name"
}

edit_existing_script() {
    echo "Scripts dispon√≠veis:"
    ls -1 "$MINER_SCRIPTS"/*.sh 2>/dev/null | xargs -n1 basename
    
    read -p "Nome do script para editar: " script_name
    
    local script_path="$MINER_SCRIPTS/$script_name"
    
    if [[ -f "$script_path" ]]; then
        if command -v nano > /dev/null; then
            nano "$script_path"
        elif command -v vi > /dev/null; then
            vi "$script_path"
        else
            echo "Nenhum editor encontrado. Instale nano ou vi."
        fi
        log_audit "Script editado: $script_name"
    else
        echo "Script n√£o encontrado!"
    fi
}

list_scripts() {
    echo "=== SCRIPTS DISPON√çVEIS ==="
    echo ""
    
    if ls "$MINER_SCRIPTS"/*.sh > /dev/null 2>&1; then
        for script in "$MINER_SCRIPTS"/*.sh; do
            script_name=$(basename "$script")
            script_size=$(du -h "$script" | cut -f1)
            script_perms=$(stat -c "%A" "$script")
            echo "  $script_name ($script_size) [$script_perms]"
        done
    else
        echo "  Nenhum script encontrado."
    fi
    
    echo ""
    read -p "Pressione Enter para continuar..."
}

execute_script() {
    echo "Scripts dispon√≠veis:"
    ls -1 "$MINER_SCRIPTS"/*.sh 2>/dev/null | xargs -n1 basename
    
    read -p "Nome do script para executar: " script_name
    
    local script_path="$MINER_SCRIPTS/$script_name"
    
    if [[ -f "$script_path" ]]; then
        echo "Executando $script_name..."
        echo "----------------------------------------"
        bash "$script_path"
        echo "----------------------------------------"
        log_audit "Script executado: $script_name"
    else
        echo "Script n√£o encontrado!"
    fi
    
    read -p "Pressione Enter para continuar..."
}

delete_script() {
    echo "Scripts dispon√≠veis:"
    ls -1 "$MINER_SCRIPTS"/*.sh 2>/dev/null | xargs -n1 basename
    
    read -p "Nome do script para deletar: " script_name
    
    local script_path="$MINER_SCRIPTS/$script_name"
    
    if [[ -f "$script_path" ]]; then
        read -p "Tem certeza que deseja deletar $script_name? (s/n): " confirm
        if [[ "$confirm" == "s" ]]; then
            rm -f "$script_path"
            echo "Script deletado!"
            log_audit "Script deletado: $script_name"
        fi
    else
        echo "Script n√£o encontrado!"
    fi
}

# ============================================================================
# TASK MANAGER (AGENDADOR DE TAREFAS)
# ============================================================================

task_manager() {
    echo "=== TASK MANAGER ==="
    echo ""
    
    while true; do
        echo "1) Listar tarefas agendadas"
        echo "2) Adicionar nova tarefa"
        echo "3) Editar tarefa existente"
        echo "4) Remover tarefa"
        echo "5) Executar tarefa manualmente"
        echo "6) Voltar ao menu"
        echo ""
        
        read -p "Escolha uma op√ß√£o: " task_choice
        
        case $task_choice in
            1)
                list_scheduled_tasks
                ;;
            2)
                add_new_task
                ;;
            3)
                edit_existing_task
                ;;
            4)
                remove_task
                ;;
            5)
                execute_task_manual
                ;;
            6)
                break
                ;;
            *)
                echo "Op√ß√£o inv√°lida!"
                ;;
        esac
    done
}

list_scheduled_tasks() {
    echo "=== TAREFAS AGENDADAS ==="
    echo ""
    
    if [[ -f "$MINER_JOBS/tasks.conf" ]]; then
        cat -n "$MINER_JOBS/tasks.conf"
    else
        echo "Nenhuma tarefa agendada."
    fi
    
    echo ""
    read -p "Pressione Enter para continuar..."
}

add_new_task() {
    echo "=== ADICIONAR NOVA TAREFA ==="
    echo ""
    
    read -p "Schedule (cron format, ex: '0 * * * *' para hora em hora): " cron_schedule
    read -p "Comando/script para executar: " task_command
    
    # Validar formato cron b√°sico
    if [[ ! "$cron_schedule" =~ ^[0-9*/, -]+$ ]]; then
        echo "Formato cron inv√°lido!"
        return
    fi
    
    # Adicionar √† lista de tarefas
    echo "$cron_schedule $task_command" >> "$MINER_JOBS/tasks.conf"
    echo "Tarefa adicionada com sucesso!"
    
    # Atualizar crontab
    update_crontab
    
    log_audit "Tarefa adicionada: $cron_schedule $task_command"
}

update_crontab() {
    # Salvar crontab atual
    crontab -l > /tmp/current_crontab 2>/dev/null
    
    # Adicionar nossas tarefas
    cat "$MINER_JOBS/tasks.conf" >> /tmp/current_crontab
    
    # Instalar novo crontab
    crontab /tmp/current_crontab
    
    rm -f /tmp/current_crontab
}

edit_existing_task() {
    list_scheduled_tasks
    
    read -p "N√∫mero da tarefa para editar: " task_num
    
    if [[ ! "$task_num" =~ ^[0-9]+$ ]]; then
        echo "N√∫mero inv√°lido!"
        return
    fi
    
    # Criar arquivo tempor√°rio
    cp "$MINER_JOBS/tasks.conf" "$MINER_JOBS/tasks.conf.bak"
    
    # Editar linha espec√≠fica
    if command -v sed > /dev/null; then
        read -p "Novo schedule: " new_schedule
        read -p "Novo comando: " new_command
        
        sed -i "${task_num}s/.*/$new_schedule $new_command/" "$MINER_JOBS/tasks.conf"
        
        echo "Tarefa editada com sucesso!"
        update_crontab
        log_audit "Tarefa editada: linha $task_num"
    else
        echo "Comando 'sed' n√£o encontrado!"
    fi
}

remove_task() {
    list_scheduled_tasks
    
    read -p "N√∫mero da tarefa para remover: " task_num
    
    if [[ ! "$task_num" =~ ^[0-9]+$ ]]; then
        echo "N√∫mero inv√°lido!"
        return
    fi
    
    # Criar backup
    cp "$MINER_JOBS/tasks.conf" "$MINER_JOBS/tasks.conf.bak"
    
    # Remover linha
    if command -v sed > /dev/null; then
        sed -i "${task_num}d" "$MINER_JOBS/tasks.conf"
        echo "Tarefa removida com sucesso!"
        update_crontab
        log_audit "Tarefa removida: linha $task_num"
    else
        echo "Comando 'sed' n√£o encontrado!"
    fi
}

execute_task_manual() {
    read -p "Comando para executar manualmente: " manual_command
    
    echo "Executando: $manual_command"
    echo "----------------------------------------"
    eval "$manual_command"
    echo "----------------------------------------"
    
    log_audit "Tarefa executada manualmente: $manual_command"
    read -p "Pressione Enter para continuar..."
}

# ============================================================================
# EVENT SYSTEM (SISTEMA DE EVENTOS)
# ============================================================================

event_system() {
    echo "=== SISTEMA DE EVENTOS ==="
    echo ""
    
    while true; do
        echo "1) Listar eventos configurados"
        echo "2) Adicionar novo evento"
        echo "3) Configurar trigger de evento"
        echo "4) Testar evento"
        echo "5) Remover evento"
        echo "6) Voltar ao menu"
        echo ""
        
        read -p "Escolha uma op√ß√£o: " event_choice
        
        case $event_choice in
            1)
                list_events
                ;;
            2)
                add_event
                ;;
            3)
                configure_event_trigger
                ;;
            4)
                test_event
                ;;
            5)
                remove_event
                ;;
            6)
                break
                ;;
            *)
                echo "Op√ß√£o inv√°lida!"
                ;;
        esac
    done
}

list_events() {
    echo "=== EVENTOS CONFIGURADOS ==="
    echo ""
    
    if [[ -d "$MINER_EVENTS" ]]; then
        for event_file in "$MINER_EVENTS"/*.sh; do
            if [[ -f "$event_file" ]]; then
                event_name=$(basename "$event_file" .sh)
                echo "  Evento: $event_name"
            fi
        done
    else
        echo "Nenhum evento configurado."
    fi
    
    echo ""
    read -p "Pressione Enter para continuar..."
}

add_event() {
    read -p "Nome do novo evento: " event_name
    
    local event_file="$MINER_EVENTS/${event_name}.sh"
    
    if [[ -f "$event_file" ]]; then
        echo "Evento j√° existe!"
        return
    fi
    
    # Criar template do evento
    cat > "$event_file" << EOF
#!/data/data/com.termux/files/usr/bin/bash
# Evento: $event_name
# Criado em: $(date)

echo "[EVENTO] $event_name disparado em \$(date)"
# Adicione suas a√ß√µes aqui

# Exemplo: enviar notifica√ß√£o Discord
# curl -H "Content-Type: application/json" -X POST -d '{"content":"Evento $event_name disparado"}' \$DISCORD_WEBHOOK
EOF
    
    chmod +x "$event_file"
    echo "Evento criado: $event_file"
    log_event "Evento criado: $event_name"
}

configure_event_trigger() {
    echo "Tipos de trigger dispon√≠veis:"
    echo "  1) On Mining Start"
    echo "  2) On Mining Stop"
    echo "  3) On Share Accepted"
    echo "  4) On Error"
    echo "  5) On Temperature High"
    echo "  6) Custom Schedule"
    
    read -p "Escolha o tipo de trigger: " trigger_type
    
    case $trigger_type in
        1)
            echo "Trigger configurado: On Mining Start"
            ;;
        2)
            echo "Trigger configurado: On Mining Stop"
            ;;
        3)
            echo "Trigger configurado: On Share Accepted"
            ;;
        4)
            echo "Trigger configurado: On Error"
            ;;
        5)
            read -p "Temperatura limite (em ¬∞C): " temp_limit
            echo "Trigger configurado: On Temperature High (>${temp_limit}¬∞C)"
            ;;
        6)
            read -p "Schedule (cron format): " cron_schedule
            echo "Trigger configurado: Schedule $cron_schedule"
            ;;
        *)
            echo "Tipo de trigger inv√°lido!"
            ;;
    esac
}

test_event() {
    list_events
    
    read -p "Nome do evento para testar: " event_name
    
    local event_file="$MINER_EVENTS/${event_name}.sh"
    
    if [[ -f "$event_file" ]]; then
        echo "Testando evento: $event_name"
        echo "----------------------------------------"
        bash "$event_file"
        echo "----------------------------------------"
        log_event "Evento testado: $event_name"
    else
        echo "Evento n√£o encontrado!"
    fi
    
    read -p "Pressione Enter para continuar..."
}

remove_event() {
    list_events
    
    read -p "Nome do evento para remover: " event_name
    
    local event_file="$MINER_EVENTS/${event_name}.sh"
    
    if [[ -f "$event_file" ]]; then
        read -p "Tem certeza que deseja remover o evento $event_name? (s/n): " confirm
        if [[ "$confirm" == "s" ]]; then
            rm -f "$event_file"
            echo "Evento removido!"
            log_event "Evento removido: $event_name"
        fi
    else
        echo "Evento n√£o encontrado!"
    fi
}

# ============================================================================
# HOOK SYSTEM
# ============================================================================

hook_system() {
    echo "=== SISTEMA DE HOOKS ==="
    echo ""
    
    while true; do
        echo "1) Listar hooks configurados"
        echo "2) Adicionar novo hook"
        echo "3) Testar hook"
        echo "4) Remover hook"
        echo "5) Voltar ao menu"
        echo ""
        
        read -p "Escolha uma op√ß√£o: " hook_choice
        
        case $hook_choice in
            1)
                list_hooks
                ;;
            2)
                add_hook
                ;;
            3)
                test_hook
                ;;
            4)
                remove_hook
                ;;
            5)
                break
                ;;
            *)
                echo "Op√ß√£o inv√°lida!"
                ;;
        esac
    done
}

list_hooks() {
    echo "=== HOOKS CONFIGURADOS ==="
    echo ""
    
    if [[ -d "$MINER_HOOKS" ]]; then
        for hook_file in "$MINER_HOOKS"/*.sh; do
            if [[ -f "$hook_file" ]]; then
                hook_name=$(basename "$hook_file" .sh)
                echo "  Hook: $hook_name"
            fi
        done
    else
        echo "Nenhum hook configurado."
    fi
    
    echo ""
    read -p "Pressione Enter para continuar..."
}

add_hook() {
    read -p "Nome do novo hook: " hook_name
    read -p "Evento para vincular (ex: mining_start, mining_stop): " hook_event
    
    local hook_file="$MINER_HOOKS/${hook_name}.sh"
    
    if [[ -f "$hook_file" ]]; then
        echo "Hook j√° existe!"
        return
    fi
    
    # Criar template do hook
    cat > "$hook_file" << EOF
#!/data/data/com.termux/files/usr/bin/bash
# Hook: $hook_name
# Evento: $hook_event
# Criado em: $(date)

echo "[HOOK] $hook_name executado para evento: $hook_event"
echo "Timestamp: \$(date)"
echo "Par√¢metros recebidos: \$@"

# Exemplo de a√ß√µes:
# - Enviar notifica√ß√£o
# - Registrar em log
# - Executar script adicional
# - Fazer backup

# Registar execu√ß√£o
echo "\$(date) - Hook $hook_name executado" >> "$MINER_LOGS/hooks.log"
EOF
    
    chmod +x "$hook_file"
    echo "Hook criado: $hook_file"
    
    # Registrar hook no sistema de eventos
    echo "$hook_event:$hook_file" >> "$MINER_HOOKS/hooks_registry.conf"
    
    log_audit "Hook criado: $hook_name para evento $hook_event"
}

test_hook() {
    list_hooks
    
    read -p "Nome do hook para testar: " hook_name
    
    local hook_file="$MINER_HOOKS/${hook_name}.sh"
    
    if [[ -f "$hook_file" ]]; then
        echo "Testando hook: $hook_name"
        echo "----------------------------------------"
        bash "$hook_file" "test_param1" "test_param2"
        echo "----------------------------------------"
        log_audit "Hook testado: $hook_name"
    else
        echo "Hook n√£o encontrado!"
    fi
    
    read -p "Pressione Enter para continuar..."
}

remove_hook() {
    list_hooks
    
    read -p "Nome do hook para remover: " hook_name
    
    local hook_file="$MINER_HOOKS/${hook_name}.sh"
    
    if [[ -f "$hook_file" ]]; then
        read -p "Tem certeza que deseja remover o hook $hook_name? (s/n): " confirm
        if [[ "$confirm" == "s" ]]; then
            rm -f "$hook_file"
            
            # Remover do registro
            sed -i "/$hook_name/d" "$MINER_HOOKS/hooks_registry.conf" 2>/dev/null
            
            echo "Hook removido!"
            log_audit "Hook removido: $hook_name"
        fi
    else
        echo "Hook n√£o encontrado!"
    fi
}

# ============================================================================
# PLUGIN MANAGER
# ============================================================================

plugin_manager() {
    echo "=== GERENCIADOR DE PLUGINS ==="
    echo ""
    
    while true; do
        echo "1) Listar plugins instalados"
        echo "2) Instalar novo plugin"
        echo "3) Ativar/Desativar plugin"
        echo "4) Remover plugin"
        echo "5) Procurar plugins online"
        echo "6) Voltar ao menu"
        echo ""
        
        read -p "Escolha uma op√ß√£o: " plugin_choice
        
        case $plugin_choice in
            1)
                list_plugins
                ;;
            2)
                install_plugin
                ;;
            3)
                toggle_plugin
                ;;
            4)
                remove_plugin
                ;;
            5)
                search_plugins_online
                ;;
            6)
                break
                ;;
            *)
                echo "Op√ß√£o inv√°lida!"
                ;;
        esac
    done
}

list_plugins() {
    echo "=== PLUGINS INSTALADOS ==="
    echo ""
    
    if [[ -d "$MINER_PLUGINS" ]]; then
        for plugin_file in "$MINER_PLUGINS"/*.sh; do
            if [[ -f "$plugin_file" ]]; then
                plugin_name=$(basename "$plugin_file" .sh)
                plugin_status="Desativado"
                
                if [[ -x "$plugin_file" ]]; then
                    plugin_status="${GREEN}Ativado${NC}"
                else
                    plugin_status="${RED}Desativado${NC}"
                fi
                
                echo -e "  Plugin: $plugin_name - Status: $plugin_status"
            fi
        done
    else
        echo "Nenhum plugin instalado."
    fi
    
    echo ""
    read -p "Pressione Enter para continuar..."
}

install_plugin() {
    echo "=== INSTALAR PLUGIN ==="
    echo ""
    
    echo "1) Instalar a partir de URL"
    echo "2) Instalar a partir de arquivo local"
    echo "3) Criar novo plugin"
    echo ""
    
    read -p "Escolha uma op√ß√£o: " install_method
    
    case $install_method in
        1)
            read -p "URL do plugin (raw GitHub URL): " plugin_url
            read -p "Nome do plugin: " plugin_name
            
            local plugin_file="$MINER_PLUGINS/${plugin_name}.sh"
            
            if wget -q "$plugin_url" -O "$plugin_file"; then
                chmod +x "$plugin_file"
                echo "Plugin instalado com sucesso!"
                log_plugin "Plugin instalado via URL: $plugin_name"
            else
                echo "Falha ao baixar plugin!"
            fi
            ;;
        2)
            read -p "Caminho do arquivo do plugin: " plugin_path
            read -p "Nome do plugin: " plugin_name
            
            local plugin_file="$MINER_PLUGINS/${plugin_name}.sh"
            
            if cp "$plugin_path" "$plugin_file"; then
                chmod +x "$plugin_file"
                echo "Plugin instalado com sucesso!"
                log_plugin "Plugin instalado localmente: $plugin_name"
            else
                echo "Falha ao copiar plugin!"
            fi
            ;;
        3)
            create_new_plugin
            ;;
        *)
            echo "Op√ß√£o inv√°lida!"
            ;;
    esac
}

create_new_plugin() {
    read -p "Nome do novo plugin: " plugin_name
    
    local plugin_file="$MINER_PLUGINS/${plugin_name}.sh"
    
    if [[ -f "$plugin_file" ]]; then
        echo "Plugin j√° existe!"
        return
    fi
    
    # Criar template do plugin
    cat > "$plugin_file" << EOF
#!/data/data/com.termux/files/usr/bin/bash
# Plugin: $plugin_name
# Vers√£o: 1.0
# Autor: $USER
# Descri√ß√£o: Plugin personalizado para Bitcoin Miner Ultimate

PLUGIN_NAME="$plugin_name"
PLUGIN_VERSION="1.0"

plugin_init() {
    echo "Plugin \$PLUGIN_NAME v\$PLUGIN_VERSION inicializado"
    return 0
}

plugin_execute() {
    local command="\$1"
    local args="\${@:2}"
    
    case "\$command" in
        "test")
            echo "Teste do plugin \$PLUGIN_NAME executado com sucesso!"
            ;;
        "info")
            echo "Informa√ß√µes do plugin:"
            echo "  Nome: \$PLUGIN_NAME"
            echo "  Vers√£o: \$PLUGIN_VERSION"
            echo "  Autor: $USER"
            ;;
        *)
            echo "Comando n√£o reconhecido: \$command"
            echo "Comandos dispon√≠veis: test, info"
            ;;
    esac
}

# Inicializar plugin
plugin_init

# Se o script foi chamado diretamente, executar comando
if [[ "\${BASH_SOURCE[0]}" == "\${0}" ]]; then
    plugin_execute "\$@"
fi
EOF
    
    chmod +x "$plugin_file"
    echo "Plugin criado: $plugin_file"
    log_plugin "Plugin criado: $plugin_name"
}

toggle_plugin() {
    list_plugins
    
    read -p "Nome do plugin para ativar/desativar: " plugin_name
    
    local plugin_file="$MINER_PLUGINS/${plugin_name}.sh"
    
    if [[ -f "$plugin_file" ]]; then
        if [[ -x "$plugin_file" ]]; then
            chmod -x "$plugin_file"
            echo "Plugin desativado: $plugin_name"
            log_plugin "Plugin desativado: $plugin_name"
        else
            chmod +x "$plugin_file"
            echo "Plugin ativado: $plugin_name"
            log_plugin "Plugin ativado: $plugin_name"
        fi
    else
        echo "Plugin n√£o encontrado!"
    fi
}

remove_plugin() {
    list_plugins
    
    read -p "Nome do plugin para remover: " plugin_name
    
    local plugin_file="$MINER_PLUGINS/${plugin_name}.sh"
    
    if [[ -f "$plugin_file" ]]; then
        read -p "Tem certeza que deseja remover o plugin $plugin_name? (s/n): " confirm
        if [[ "$confirm" == "s" ]]; then
            rm -f "$plugin_file"
            echo "Plugin removido!"
            log_plugin "Plugin removido: $plugin_name"
        fi
    else
        echo "Plugin n√£o encontrado!"
    fi
}

search_plugins_online() {
    echo "=== PROCURAR PLUGINS ONLINE ==="
    echo ""
    echo "Funcionalidade em desenvolvimento..."
    echo "Em vers√µes futuras, voc√™ poder√° procurar plugins em um reposit√≥rio online."
    echo ""
    read -p "Pressione Enter para continuar..."
}

# ============================================================================
# MOBILE ALERTS SYSTEM (SEM MENCIONAR BATERIA)
# ============================================================================

mobile_alerts_system() {
    echo "=== SISTEMA DE ALERTAS MOBILE ==="
    echo ""
    
    while true; do
        echo "1) Configurar alertas"
        echo "2) Testar alertas"
        echo "3) Visualizar hist√≥rico de alertas"
        echo "4) Limpar hist√≥rico de alertas"
        echo "5) Voltar ao menu"
        echo ""
        
        read -p "Escolha uma op√ß√£o: " alert_choice
        
        case $alert_choice in
            1)
                configure_alerts
                ;;
            2)
                test_alerts
                ;;
            3)
                view_alert_history
                ;;
            4)
                clear_alert_history
                ;;
            5)
                break
                ;;
            *)
                echo "Op√ß√£o inv√°lida!"
                ;;
        esac
    done
}

configure_alerts() {
    echo "=== CONFIGURAR ALERTAS ==="
    echo ""
    
    echo "Tipos de alerta dispon√≠veis:"
    echo "  1) Alerta de in√≠cio/minera√ß√£o"
    echo "  2) Alerta de parada/minera√ß√£o"
    echo "  3) Alerta de erro no sistema"
    echo "  4) Alerta de share aceito"
    echo "  5) Alerta de temperatura alta"
    echo "  6) Alerta de desconex√£o da pool"
    echo ""
    
    read -p "Escolha o tipo de alerta: " alert_type
    
    case $alert_type in
        1)
            echo "Alerta configurado: In√≠cio de minera√ß√£o"
            echo "ALERT_MINING_START=true" >> "$MINER_ALERTS/alerts_config.conf"
            ;;
        2)
            echo "Alerta configurado: Parada de minera√ß√£o"
            echo "ALERT_MINING_STOP=true" >> "$MINER_ALERTS/alerts_config.conf"
            ;;
        3)
            echo "Alerta configurado: Erro no sistema"
            echo "ALERT_SYSTEM_ERROR=true" >> "$MINER_ALERTS/alerts_config.conf"
            ;;
        4)
            read -p "Limite de shares para alerta (padr√£o: 1): " share_limit
            share_limit=${share_limit:-1}
            echo "ALERT_SHARE_ACCEPTED=$share_limit" >> "$MINER_ALERTS/alerts_config.conf"
            echo "Alerta configurado: Share aceito (limite: $share_limit)"
            ;;
        5)
            read -p "Temperatura limite para alerta (em ¬∞C): " temp_limit
            echo "ALERT_TEMP_HIGH=$temp_limit" >> "$MINER_ALERTS/alerts_config.conf"
            echo "Alerta configurado: Temperatura alta (>${temp_limit}¬∞C)"
            ;;
        6)
            echo "Alerta configurado: Desconex√£o da pool"
            echo "ALERT_POOL_DISCONNECT=true" >> "$MINER_ALERTS/alerts_config.conf"
            ;;
        *)
            echo "Tipo de alerta inv√°lido!"
            ;;
    esac
    
    log_audit "Alerta configurado: tipo $alert_type"
}

test_alerts() {
    echo "=== TESTAR ALERTAS ==="
    echo ""
    
    echo "1) Testar alerta de in√≠cio de minera√ß√£o"
    echo "2) Testar alerta de erro no sistema"
    echo "3) Testar alerta gen√©rico"
    echo ""
    
    read -p "Escolha um teste: " test_choice
    
    local test_message=""
    
    case $test_choice in
        1)
            test_message="üöÄ TESTE: Alerta de in√≠cio de minera√ß√£o"
            discord_send "$test_message\n\nEste √© um teste do sistema de alertas." "3066993" "üß™ TESTE DE ALERTA"
            ;;
        2)
            test_message="‚ùå TESTE: Alerta de erro no sistema"
            discord_send "$test_message\n\nEste √© um teste do sistema de alertas." "15158332" "üß™ TESTE DE ALERTA"
            ;;
        3)
            test_message="üì¢ TESTE: Alerta gen√©rico do sistema"
            discord_send "$test_message\n\nEste √© um teste do sistema de alertas." "3447003" "üß™ TESTE DE ALERTA"
            ;;
        *)
            echo "Op√ß√£o inv√°lida!"
            return
            ;;
    esac
    
    echo "Alerta de teste enviado: $test_message"
    log_audit "Alerta de teste enviado: tipo $test_choice"
}

view_alert_history() {
    echo "=== HIST√ìRICO DE ALERTAS ==="
    echo ""
    
    if [[ -f "$MINER_ALERTS/alert_history.log" ]]; then
        cat "$MINER_ALERTS/alert_history.log"
    else
        echo "Nenhum alerta registrado no hist√≥rico."
    fi
    
    echo ""
    read -p "Pressione Enter para continuar..."
}

clear_alert_history() {
    if [[ -f "$MINER_ALERTS/alert_history.log" ]]; then
        read -p "Tem certeza que deseja limpar o hist√≥rico de alertas? (s/n): " confirm
        if [[ "$confirm" == "s" ]]; then
            rm -f "$MINER_ALERTS/alert_history.log"
            echo "Hist√≥rico de alertas limpo!"
            log_audit "Hist√≥rico de alertas limpo"
        fi
    else
        echo "Hist√≥rico de alertas j√° est√° vazio."
    fi
}

# ============================================================================
# FUN√á√ïES PRINCIPAIS DO MINERADOR
# ============================================================================

start_mining() {
    log_miner "Iniciando processo de minera√ß√£o..."
    
    # Verificar se j√° est√° rodando
    if is_mining_running; then
        log_warning "Minerador j√° est√° em execu√ß√£o"
        return 1
    fi
    
    # Aplicar otimiza√ß√µes
    optimize_system
    
    # Iniciar XMRig
    cd "$MINER_ROOT"
    nohup "$MINER_BIN/xmrig" -c "$MINER_CONFIG/config.json" > "$MINER_LOGS/miner_console.log" 2>&1 &
    
    # Aguardar inicializa√ß√£o
    sleep 5
    
    if is_mining_running; then
        local worker_id=$(get_worker_id)
        log_success "Minera√ß√£o iniciada com sucesso"
        log_audit "Minera√ß√£o iniciada"
        
        # Enviar alerta Discord
        discord_mining_start "$worker_id"
        
        # Disparar hooks/eventos
        trigger_event "mining_start" "$worker_id"
        
        return 0
    else
        log_error "Falha ao iniciar minera√ß√£o"
        return 1
    fi
}

stop_mining() {
    log_miner "Parando minera√ß√£o..."
    
    if ! is_mining_running; then
        log_warning "Minerador n√£o est√° em execu√ß√£o"
        return 1
    fi
    
    # Parar processo
    pkill -f xmrig
    
    # Aguardar parada
    sleep 2
    
    if is_mining_running; then
        log_warning "For√ßando parada do minerador..."
        pkill -9 -f xmrig
    fi
    
    if ! is_mining_running; then
        local worker_id=$(get_worker_id)
        log_success "Minera√ß√£o parada"
        log_audit "Minera√ß√£o parada"
        
        # Enviar alerta Discord
        discord_mining_stop "$worker_id"
        
        # Disparar hooks/eventos
        trigger_event "mining_stop" "$worker_id"
        
        return 0
    else
        log_error "Falha ao parar minera√ß√£o"
        return 1
    fi
}

restart_mining() {
    log_miner "Reiniciando minera√ß√£o..."
    
    stop_mining
    sleep 3
    start_mining
}

is_mining_running() {
    pgrep -f xmrig > /dev/null 2>&1
    return $?
}

get_worker_id() {
    if [ -f "$MINER_CONFIG/system.info" ]; then
        grep "^WORKER_ID=" "$MINER_CONFIG/system.info" | cut -d= -f2
    else
        echo "unknown"
    fi
}

get_accepted_shares() {
    if [ -f "$MINER_STATS/shares" ]; then
        grep "^accepted:" "$MINER_STATS/shares" | cut -d: -f2
    else
        echo "0"
    fi
}

get_mining_uptime() {
    if is_mining_running; then
        local pid=$(pgrep -f xmrig)
        local uptime=$(ps -o etimes= -p $pid 2>/dev/null | xargs)
        if [ -n "$uptime" ]; then
            local hours=$((uptime / 3600))
            local minutes=$(((uptime % 3600) / 60))
            echo "${hours}h ${minutes}m"
        else
            echo "unknown"
        fi
    else
        echo "not running"
    fi
}

trigger_event() {
    local event_name="$1"
    shift
    local event_args="$@"
    
    # Executar hooks registrados para este evento
    if [ -f "$MINER_HOOKS/hooks_registry.conf" ]; then
        grep "^$event_name:" "$MINER_HOOKS/hooks_registry.conf" | while read line; do
            hook_file=$(echo "$line" | cut -d: -f2)
            if [ -f "$hook_file" ] && [ -x "$hook_file" ]; then
                bash "$hook_file" "$event_name" "$event_args"
            fi
        done
    fi
    
    log_event "Evento disparado: $event_name com args: $event_args"
}

optimize_system() {
    log_performance "Otimizando sistema para minera√ß√£o..."
    
    # Ajustar prioridade do processo
    renice -n -20 $$
    
    # Otimizar configura√ß√µes de rede
    echo "net.core.rmem_max = 134217728" >> /etc/sysctl.conf 2>/dev/null
    echo "net.core.wmem_max = 134217728" >> /etc/sysctl.conf 2>/dev/null
    
    # Ajustar limites de arquivos
    ulimit -n 65536 2>/dev/null
    
    log_success "Sistema otimizado para minera√ß√£o"
    log_audit "Otimiza√ß√£o do sistema aplicada"
}

# ============================================================================
# DASHBOARD EM TEMPO REAL (MOBILE RESPONSIVE)
# ============================================================================

show_dashboard() {
    clear
    
    # Detectar tamanho do terminal
    local cols=$(tput cols)
    local lines=$(tput lines)
    
    # Layout responsivo
    if [ $cols -lt 80 ]; then
        show_mobile_dashboard
        return
    fi
    
    # Dashboard Desktop
    echo -e "${COLOR_TITLE}"
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë                     BITCOIN MINER ULTIMATE - DASHBOARD                          ‚ïë"
    echo "‚ïë                               v10.0 - Sistema Profissional                      ‚ïë"
    echo "‚ïë                             $(date '+%Y-%m-%d %H:%M:%S')                             ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo -e "${NC}"
    
    # Status do Minerador
    echo -e "${COLOR_STATUS}üîß STATUS DO MINERADOR${NC}"
    echo -e "${TEAL}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    
    if is_mining_running; then
        local pid=$(pgrep -f xmrig)
        
        echo -e "${COLOR_SUCCESS}‚ñ∂ MINERA√á√ÉO: ${GREEN}ATIVA${NC}"
        echo -e "   PID: $pid"
        
        # Uptime
        local uptime=$(get_mining_uptime)
        echo -e "   ‚è±Ô∏è  Uptime: $uptime"
        
        # Hashrate
        if [ -f "$MINER_STATS/current_hashrate" ]; then
            local hashrate=$(cat "$MINER_STATS/current_hashrate")
            echo -e "   ‚ö° ${COLOR_HASHRATE}Hashrate: $hashrate H/s${NC}"
        fi
        
        # Temperatura
        if [ -f "$MINER_STATS/cpu_temp" ]; then
            local temp=$(cat "$MINER_STATS/cpu_temp")
            if [ "$temp" -gt 80 ]; then
                echo -e "   üå°Ô∏è  ${COLOR_ERROR}Temperatura: ${temp}¬∞C ‚ö†Ô∏è${NC}"
            elif [ "$temp" -gt 70 ]; then
                echo -e "   üå°Ô∏è  ${COLOR_WARNING}Temperatura: ${temp}¬∞C${NC}"
            else
                echo -e "   üå°Ô∏è  ${COLOR_INFO}Temperatura: ${temp}¬∞C${NC}"
            fi
        fi
    else
        echo -e "${COLOR_ERROR}‚ñ∂ MINERA√á√ÉO: ${RED}INATIVA${NC}"
    fi
    
    echo ""
    
    # Estat√≠sticas
    echo -e "${COLOR_INFO}üìä ESTAT√çSTICAS DE MINERA√á√ÉO${NC}"
    echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    
    if [ -f "$MINER_STATS/shares" ]; then
        local accepted=$(get_accepted_shares)
        local rejected=$(grep "^rejected:" "$MINER_STATS/shares" 2>/dev/null | cut -d: -f2)
        rejected=${rejected:-0}
        
        echo -e "   ${GREEN}‚úÖ Shares Aceitos: $accepted${NC}"
        echo -e "   ${RED}‚ùå Shares Rejeitados: $rejected${NC}"
        
        if [ $((accepted + rejected)) -gt 0 ]; then
            local rate=$(echo "scale=1; $accepted * 100 / ($accepted + $rejected)" | bc 2>/dev/null)
            if [ -n "$rate" ]; then
                echo -e "   ${CYAN}üìà Taxa de Aceita√ß√£o: ${rate}%${NC}"
            fi
        fi
    fi
    
    # Lucro Estimado
    if [ -f "$MINER_STATS/current_hashrate" ]; then
        local hashrate=$(cat "$MINER_STATS/current_hashrate" | grep -oE "[0-9]+\.[0-9]+" || echo "0")
        if [ "$hashrate" != "0" ]; then
            local satoshis=$(echo "$hashrate * 150" | bc 2>/dev/null | cut -d. -f1)
            satoshis=${satoshis:-0}
            
            if [ "$satoshis" -gt 0 ]; then
                local btc=$(echo "scale=8; $satoshis / 100000000" | bc 2>/dev/null)
                local usd=$(echo "scale=2; $btc * 45000" | bc 2>/dev/null)
                
                echo -e "   ${COLOR_PROFIT}üí∞ Lucro Estimado por Dia:${NC}"
                echo -e "      ${GOLD}Satoshis:${NC} $satoshis"
                echo -e "      ${GOLD}BTC:${NC} $btc"
                echo -e "      ${GOLD}USD:${NC} \$$usd"
            fi
        fi
    fi
    
    echo ""
    
    # Informa√ß√µes do Sistema
    echo -e "${COLOR_MENU}üíª INFORMA√á√ïES DO SISTEMA${NC}"
    echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    
    if [ -f "$MINER_CONFIG/system.info" ]; then
        echo -e "   ${CYAN}üë∑ Worker ID:${NC} $(get_worker_id)"
        echo -e "   ${CYAN}üåê Pool:${NC} $(grep '^POOL=' "$MINER_CONFIG/system.info" 2>/dev/null | cut -d= -f2)"
        echo -e "   ${CYAN}üí∞ Carteira:${NC} ${BTC_WALLET_MAIN:0:10}..."
        echo -e "   ${CYAN}‚öôÔ∏è  Threads CPU:${NC} $CPU_THREADS"
        echo -e "   ${CYAN}üìÖ Instalado em:${NC} $(grep '^INSTALL_DATE=' "$MINER_CONFIG/system.info" 2>/dev/null | cut -d= -f2)"
    fi
    
    echo ""
    
    # Status de Servi√ßos
    echo -e "${COLOR_WEB}üåê STATUS DE SERVI√áOS${NC}"
    echo -e "${TURQUOISE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    
    echo -e "   üöÄ Minera√ß√£o: $(check_service_status mining)"
    echo -e "   üìä Monitor: $(check_service_status monitor)"
    echo -e "   üîå API REST: $(check_service_status api)"
    echo -e "   ‚ö° WebSocket: $(check_service_status websocket)"
    echo -e "   üß© Plugins: $(count_active_plugins) ativos"
    
    echo ""
    
    # Logs Recentes
    echo -e "${COLOR_MATRIX}üìú LOGS RECENTES${NC}"
    echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    
    if [ -f "$MINER_LOGS/miner_console.log" ]; then
        tail -3 "$MINER_LOGS/miner_console.log" | while read line; do
            echo -e "   ${line:0:70}..."
        done
    else
        echo "   Nenhum log dispon√≠vel"
    fi
    
    echo ""
    echo -e "${COLOR_TITLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${DIM}Terminal: ${cols}x${lines} | Atualizado: $(date '+%H:%M:%S') | v10.0${NC}"
}

show_mobile_dashboard() {
    clear
    
    echo -e "${COLOR_TITLE}"
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë      BITCOIN MINER MOBILE            ‚ïë"
    echo "‚ïë           v10.0                      ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo -e "${NC}"
    
    # Status compacto
    if is_mining_running; then
        echo -e "${COLOR_SUCCESS}‚ñ∂ ATIVO${NC}"
        
        if [ -f "$MINER_STATS/current_hashrate" ]; then
            local hashrate=$(cat "$MINER_STATS/current_hashrate")
            echo -e "‚ö° $hashrate H/s"
        fi
        
        if [ -f "$MINER_STATS/cpu_temp" ]; then
            local temp=$(cat "$MINER_STATS/cpu_temp")
            echo -e "üå°Ô∏è  ${temp}¬∞C"
        fi
    else
        echo -e "${COLOR_ERROR}‚ñ∂ INATIVO${NC}"
    fi
    
    echo ""
    
    # Estat√≠sticas r√°pidas
    if [ -f "$MINER_STATS/shares" ]; then
        local accepted=$(get_accepted_shares)
        local rejected=$(grep "^rejected:" "$MINER_STATS/shares" 2>/dev/null | cut -d: -f2)
        rejected=${rejected:-0}
        echo -e "${GREEN}‚úÖ $accepted${NC} ${RED}‚ùå $rejected${NC}"
    fi
    
    echo ""
    echo -e "${COLOR_INFO}[1] Iniciar  [2] Parar${NC}"
    echo -e "${COLOR_INFO}[3] Menu     [0] Sair${NC}"
    echo ""
    
    read -t 5 -n 1 mobile_choice
    case $mobile_choice in
        1) start_mining; sleep 2 ;;
        2) stop_mining; sleep 2 ;;
        3) return ;;
        0) exit 0 ;;
    esac
}

check_service_status() {
    local service="$1"
    
    case "$service" in
        mining)
            if is_mining_running; then
                echo -e "${GREEN}‚óè Ativo${NC}"
            else
                echo -e "${RED}‚óè Inativo${NC}"
            fi
            ;;
        monitor)
            if pgrep -f "monitor.sh" > /dev/null; then
                echo -e "${GREEN}‚óè Ativo${NC}"
            else
                echo -e "${YELLOW}‚óè Parado${NC}"
            fi
            ;;
        api)
            if [ -f "$MINER_API/api.pid" ] && kill -0 $(cat "$MINER_API/api.pid") 2>/dev/null; then
                echo -e "${GREEN}‚óè Ativo${NC}"
            else
                echo -e "${YELLOW}‚óè Parado${NC}"
            fi
            ;;
        websocket)
            if [ -f "$MINER_WEB/websocket.pid" ] && kill -0 $(cat "$MINER_WEB/websocket.pid") 2>/dev/null; then
                echo -e "${GREEN}‚óè Ativo${NC}"
            else
                echo -e "${YELLOW}‚óè Parado${NC}"
            fi
            ;;
        *)
            echo -e "${YELLOW}‚óè Desconhecido${NC}"
            ;;
    esac
}

count_active_plugins() {
    local count=0
    if [ -d "$MINER_PLUGINS" ]; then
        for plugin in "$MINER_PLUGINS"/*.sh; do
            if [ -f "$plugin" ] && [ -x "$plugin" ]; then
                count=$((count + 1))
            fi
        done
    fi
    echo "$count"
}

# ============================================================================
# MENU PRINCIPAL COMPLETO
# ============================================================================

show_main_menu() {
    while true; do
        clear
        show_dashboard
        
        echo ""
        echo -e "${COLOR_MENU}üéÆ MENU PRINCIPAL - v10.0${NC}"
        echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
        echo ""
        echo -e "  ${BOLD}1)${NC} ${GREEN}üöÄ Iniciar Minera√ß√£o${NC}"
        echo -e "  ${BOLD}2)${NC} ${RED}üõë Parar Minera√ß√£o${NC}"
        echo -e "  ${BOLD}3)${NC} ${YELLOW}üîÑ Reiniciar Minerador${NC}"
        echo -e "  ${BOLD}4)${NC} ${CYAN}üìä Dashboard Detalhado${NC}"
        echo -e "  ${BOLD}5)${NC} ${MAGENTA}üìã Visualizar Logs${NC}"
        echo -e "  ${BOLD}6)${NC} ${ORANGE}üßπ Limpar Logs${NC}"
        echo -e "  ${BOLD}7)${NC} ${TEAL}‚ö° Otimizar Sistema${NC}"
        echo -e "  ${BOLD}8)${NC} ${PURPLE}üíæ Backup Sistema${NC}"
        echo -e "  ${BOLD}9)${NC} ${BLUE}üåê Web Dashboard${NC}"
        echo -e "  ${BOLD}10)${NC} ${PINK}üìù Editor de Scripts${NC}"
        echo -e "  ${BOLD}11)${NC} ${LIME}üìã Task Manager${NC}"
        echo -e "  ${BOLD}12)${NC} ${GOLD}üéØ Sistema de Eventos${NC}"
        echo -e "  ${BOLD}13)${NC} ${RED}ü™ù Hook System${NC}"
        echo -e "  ${BOLD}14)${NC} ${GREEN}üß© Plugin Manager${NC}"
        echo -e "  ${BOLD}15)${NC} ${YELLOW}üì¢ Sistema de Alertas${NC}"
        echo -e "  ${BOLD}16)${NC} ${CYAN}üîß Configura√ß√µes${NC}"
        echo -e "  ${BOLD}17)${NC} ${MAGENTA}üìà Estat√≠sticas${NC}"
        echo -e "  ${BOLD}18)${NC} ${ORANGE}üîê Seguran√ßa${NC}"
        echo -e "  ${BOLD}19)${NC} ${TEAL}üåê Testar Conex√£o${NC}"
        echo -e "  ${BOLD}20)${NC} ${PURPLE}üëõ Mudar Carteira${NC}"
        echo -e "  ${BOLD}21)${NC} ${BLUE}üèÉ‚Äç‚ôÇÔ∏è Benchmark${NC}"
        echo -e "  ${BOLD}22)${NC} ${PINK}üìú Relat√≥rios${NC}"
        echo -e "  ${BOLD}23)${NC} ${LIME}üóëÔ∏è  Limpeza${NC}"
        echo -e "  ${BOLD}24)${NC} ${GOLD}üì® Testar Discord${NC}"
        echo -e "  ${BOLD}25)${NC} ${RED}üîÑ Atualizar XMRig${NC}"
        echo -e "  ${BOLD}26)${NC} ${GREEN}üèóÔ∏è  Configurar Seguran√ßa${NC}"
        echo -e "  ${BOLD}27)${NC} ${YELLOW}üéØ Cr√©ditos${NC}"
        echo -e "  ${BOLD}0)${NC} ${RED}üö™ Sair${NC}"
        echo ""
        echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
        echo ""
        
        echo -ne "${COLOR_INPUT}Selecione uma op√ß√£o (0-27): ${NC}"
        read choice
        
        case $choice in
            1) start_mining; sleep 2 ;;
            2) stop_mining; sleep 2 ;;
            3) restart_mining; sleep 2 ;;
            4) show_dashboard; read -p "Pressione Enter para continuar..." ;;
            5) 
                echo "Tipo de logs (system, miner, error, api, web, all):"
                read log_type
                view_logs "$log_type"
                read -p "Pressione Enter para continuar..."
                ;;
            6) clear_logs; sleep 1 ;;
            7) optimize_system; sleep 1 ;;
            8) backup_system; sleep 1 ;;
            9) 
                echo "1) Iniciar Web Dashboard"
                echo "2) Parar Web Dashboard"
                echo "3) Status Web Dashboard"
                read web_choice
                case $web_choice in
                    1) start_web_dashboard; sleep 1 ;;
                    2) stop_web_dashboard; sleep 1 ;;
                    3) 
                        echo "API REST: $(check_service_status api)"
                        echo "WebSocket: $(check_service_status websocket)"
                        ;;
                esac
                read -p "Pressione Enter para continuar..."
                ;;
            10) script_editor ;;
            11) task_manager ;;
            12) event_system ;;
            13) hook_system ;;
            14) plugin_manager ;;
            15) mobile_alerts_system ;;
            16) 
                echo "1) Ver configura√ß√£o atual"
                echo "2) Editar configura√ß√£o manualmente"
                echo "3) Restaurar configura√ß√£o padr√£o"
                read config_choice
                case $config_choice in
                    1) 
                        echo "=== CONFIGURA√á√ÉO ATUAL ==="
                        cat "$MINER_CONFIG/config.json" | python -m json.tool 2>/dev/null || cat "$MINER_CONFIG/config.json"
                        read -p "Pressione Enter para continuar..."
                        ;;
                    2)
                        if command -v nano > /dev/null; then
                            nano "$MINER_CONFIG/config.json"
                        elif command -v vi > /dev/null; then
                            vi "$MINER_CONFIG/config.json"
                        else
                            echo "Nenhum editor encontrado"
                        fi
                        ;;
                    3)
                        create_configuration
                        ;;
                esac
                ;;
            17) 
                echo "=== ESTAT√çSTICAS DETALHADAS ==="
                if [ -f "$MINER_STATS/shares" ]; then
                    accepted=$(get_accepted_shares)
                    rejected=$(grep "^rejected:" "$MINER_STATS/shares" 2>/dev/null | cut -d: -f2)
                    echo "Shares Aceitos: $accepted"
                    echo "Shares Rejeitados: $rejected"
                    
                    if [ "$accepted" -gt 0 ]; then
                        local uptime=$(cat "$MINER_STATS/uptime" 2>/dev/null || echo "0")
                        if [ "$uptime" -gt 0 ]; then
                            local shares_per_hour=$(echo "scale=2; $accepted * 3600 / $uptime" | bc 2>/dev/null)
                            echo "Shares por hora: $shares_per_hour"
                        fi
                    fi
                fi
                if [ -f "$MINER_STATS/current_hashrate" ]; then
                    echo "Hashrate atual: $(cat "$MINER_STATS/current_hashrate") H/s"
                fi
                read -p "Pressione Enter para continuar..."
                ;;
            18) security_check; read -p "Pressione Enter para continuar..." ;;
            19) test_pool_connection; read -p "Pressione Enter para continuar..." ;;
            20) 
                echo "Nova carteira Bitcoin:"
                read new_wallet
                change_wallet "$new_wallet"
                sleep 2
                ;;
            21) run_benchmark; read -p "Pressione Enter para continuar..." ;;
            22) generate_report; read -p "Pressione Enter para continuar..." ;;
            23) cleanup_system; sleep 1 ;;
            24) discord_send "Teste de notifica√ß√£o do sistema" "3447003" "üß™ TESTE DE SISTEMA"; sleep 1 ;;
            25) update_xmrig; sleep 2 ;;
            26) setup_security; sleep 1 ;;
            27) show_credits ;;
            0) 
                echo "Encerrando sistema..."
                log_system "Sistema encerrado pelo usu√°rio"
                exit 0
                ;;
            *) echo -e "${COLOR_ERROR}Op√ß√£o inv√°lida!${NC}"; sleep 1 ;;
        esac
    done
}

# ============================================================================
# FUN√á√ïES AUXILIARES (completando as necess√°rias)
# ============================================================================

view_logs() {
    local log_type="$1"
    
    case "$log_type" in
        system) tail -100 "$MINER_LOGS/system.log" ;;
        miner) tail -100 "$MINER_LOGS/miner_console.log" ;;
        error) tail -100 "$MINER_LOGS/error.log" ;;
        api) tail -100 "$MINER_LOGS/api_server.log" ;;
        web) tail -100 "$MINER_LOGS/websocket.log" ;;
        all)
            for log in "$MINER_LOGS"/*.log; do
                echo "=== $(basename "$log") ==="
                tail -20 "$log"
                echo ""
            done
            ;;
        *) echo "Tipo de log desconhecido. Use: system, miner, error, api, web, all" ;;
    esac
}

clear_logs() {
    echo "Limpando logs antigos..."
    
    # Manter logs atuais, limpar backups antigos
    find "$MINER_LOGS" -name "*.log.*" -mtime +7 -delete 2>/dev/null
    find "$MINER_LOGS/daily" -name "*.log" -mtime +30 -delete 2>/dev/null
    find "$MINER_LOGS/hourly" -name "*.log" -mtime +7 -delete 2>/dev/null
    
    echo "Logs limpos!"
}

test_pool_connection() {
    local pool="${POOLS_MAIN[0]}"
    echo "Testando conex√£o com pool: $pool"
    
    local host=$(echo "$pool" | cut -d: -f1)
    local port=$(echo "$pool" | cut -d: -f2)
    
    if timeout 5 nc -z "$host" "$port" 2>/dev/null; then
        echo "‚úÖ Conex√£o bem-sucedida"
        return 0
    else
        echo "‚ùå Falha na conex√£o"
        return 1
    fi
}

change_wallet() {
    local new_wallet="$1"
    
    if [ -z "$new_wallet" ]; then
        echo "Nova carteira Bitcoin:"
        read new_wallet
    fi
    
    if [ -z "$new_wallet" ]; then
        echo "Carteira n√£o pode ser vazia!"
        return 1
    fi
    
    # Atualizar vari√°vel
    export BTC_WALLET_MAIN="$new_wallet"
    
    # Atualizar arquivo de configura√ß√£o
    local worker_id=$(get_worker_id)
    sed -i "s|\"user\": \".*\"|\"user\": \"$new_wallet.$worker_id\"|" "$MINER_CONFIG/config.json"
    sed -i "s|^BTC_WALLET=.*|BTC_WALLET=$new_wallet|" "$MINER_CONFIG/system.info"
    
    echo "Carteira atualizada para: $new_wallet"
    log_audit "Carteira alterada"
    
    # Reiniciar minera√ß√£o
    restart_mining
}

run_benchmark() {
    echo "Executando benchmark de performance..."
    
    if [ ! -f "$MINER_BIN/xmrig" ]; then
        echo "XMRig n√£o encontrado!"
        return 1
    fi
    
    echo "Benchmark em andamento... (60 segundos)"
    
    "$MINER_BIN/xmrig" --bench=10000 --print-time=10 > /tmp/benchmark.log 2>&1 &
    local bench_pid=$!
    
    for i in {1..6}; do
        echo -ne "Progresso: $((i*10))%\\r"
        sleep 10
    done
    
    kill $bench_pid 2>/dev/null
    
    # Analisar resultados
    if grep -q "totals" /tmp/benchmark.log; then
        local hashrate=$(grep "totals" /tmp/benchmark.log | tail -1 | grep -oE "[0-9]+\.[0-9]+" | head -1)
        echo ""
        echo "‚úÖ Benchmark conclu√≠do"
        echo "üìä Hashrate m√°ximo: ${hashrate} H/s"
    else
        echo "‚ùå Falha no benchmark"
    fi
}

generate_report() {
    echo "Gerando relat√≥rio do sistema..."
    
    local report_file="$MINER_REPORTS/report_$(date +%Y%m%d_%H%M%S).txt"
    
    mkdir -p "$MINER_REPORTS"
    
    cat > "$report_file" << EOF
=== RELAT√ìRIO DO SISTEMA DE MINERA√á√ÉO ===
Data: $(date '+%Y-%m-%d %H:%M:%S')

STATUS DO MINERADOR:
- Status: $(is_mining_running && echo "Ativo" || echo "Inativo")
- Worker ID: $(get_worker_id)
- Pool: $(grep '^POOL=' "$MINER_CONFIG/system.info" 2>/dev/null | cut -d= -f2)
- Carteira: ${BTC_WALLET_MAIN:0:15}...

ESTAT√çSTICAS:
- Shares Aceitos: $(get_accepted_shares)
- Hashrate Atual: $(cat "$MINER_STATS/current_hashrate" 2>/dev/null || echo "0") H/s

SISTEMA:
- CPU Threads: $CPU_THREADS
- Prioridade: $CPU_PRIORITY
- Mem√≥ria M√°xima: ${MAX_MEMORY}MB
- Otimiza√ß√£o: $OPTIMIZATION_LEVEL

LOGS RECENTES:
$(tail -10 "$MINER_LOGS/system.log" 2>/dev/null || echo "Nenhum log dispon√≠vel")

=== FIM DO RELAT√ìRIO ===
EOF
    
    echo "Relat√≥rio gerado: $report_file"
}

cleanup_system() {
    echo "Limpando sistema..."
    
    # Limpar tempor√°rios
    rm -rf "$MINER_TEMP"/*
    
    # Limpar cache antigo
    find "$MINER_CACHE" -type f -mtime +7 -delete 2>/dev/null
    
    # Limpar backups antigos
    ls -t "$MINER_BACKUP"/*.tar.gz 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null
    
    echo "Limpeza conclu√≠da!"
}

update_xmrig() {
    echo "Atualizando XMRig..."
    
    # Fazer backup
    if [ -f "$MINER_BIN/xmrig" ]; then
        cp "$MINER_BIN/xmrig" "$MINER_BACKUP/xmrig_backup_$(date +%s)"
    fi
    
    # Reinstalar
    if install_xmrig_complete; then
        echo "‚úÖ XMRig atualizado com sucesso"
    else
        echo "‚ùå Falha na atualiza√ß√£o do XMRig"
    fi
}

security_check() {
    echo "=== VERIFICA√á√ÉO DE SEGURAN√áA ==="
    echo ""
    
    echo "1. Verificando processos..."
    ps aux | grep -E "(xmrig|miner)" | grep -v grep
    
    echo ""
    echo "2. Verificando conex√µes..."
    netstat -tunap 2>/dev/null | grep ESTABLISHED | head -10
    
    echo ""
    echo "3. Verificando arquivos do sistema..."
    if [ -f "$MINER_BIN/xmrig" ]; then
        echo "‚úÖ XMRig encontrado"
    else
        echo "‚ùå XMRig n√£o encontrado"
    fi
    
    echo ""
    echo "Verifica√ß√£o conclu√≠da!"
}

setup_security() {
    echo "Configurando seguran√ßa..."
    
    mkdir -p "$MINER_SECURITY"
    
    # Gerar chaves
    echo "API_KEY_MAIN=$API_KEY_MAIN" > "$MINER_SECURITY/keys.conf"
    echo "API_KEY_ADMIN=$API_KEY_ADMIN" >> "$MINER_SECURITY/keys.conf"
    
    echo "‚úÖ Seguran√ßa configurada"
}

show_credits() {
    clear
    echo -e "${COLOR_TITLE}"
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë                           BITCOIN MINER ULTIMATE                                ‚ïë"
    echo "‚ïë                               v10.0 - Sistema Completo                         ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo -e "${NC}"
    echo ""
    echo -e "${COLOR_INFO}üéØ SISTEMA PROFISSIONAL DE MINERA√á√ÉO BITCOIN${NC}"
    echo ""
    echo -e "${COLOR_SUCCESS}‚úÖ 300+ Funcionalidades implementadas${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Dashboard em tempo real (mobile responsive)${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Web Dashboard com REST API + WebSocket${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Sistema completo de logs para Discord${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Editor de scripts integrado${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Task Manager avan√ßado${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Sistema de Eventos completo${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Hook System extens√≠vel${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Plugin Manager profissional${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Sistema de Alertas Mobile${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Monitoramento 24/7${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Backup e restore autom√°tico${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Otimiza√ß√£o m√°xima de performance${NC}"
    echo ""
    echo -e "${COLOR_WARNING}‚ö†Ô∏è  Desenvolvido para Termux - Use com responsabilidade${NC}"
    echo ""
    echo -e "${COLOR_MENU}Pressione Enter para continuar...${NC}"
    read
}

# ============================================================================
# INSTALA√á√ÉO COMPLETA DO SISTEMA
# ============================================================================

install_complete_system() {
    clear
    
    echo -e "${COLOR_TITLE}"
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë                BITCOIN MINER ULTIMATE - INSTALA√á√ÉO COMPLETA                     ‚ïë"
    echo "‚ïë                               v10.0 - 300+ Funcionalidades                      ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo -e "${NC}"
    echo ""
    echo -e "${COLOR_INFO}Este sistema inclui 300+ funcionalidades profissionais:${NC}"
    echo ""
    echo -e "${COLOR_SUCCESS}‚úÖ Sistema de minera√ß√£o Bitcoin/XMR completo${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Dashboard em tempo real com design mobile responsive${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Web Dashboard com REST API + WebSocket${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Sistema de logs profissional para Discord${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Editor de scripts integrado${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Task Manager avan√ßado${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Sistema de Eventos completo${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Hook System extens√≠vel${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Plugin Manager profissional${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Sistema de Alertas Mobile${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Monitoramento 24/7${NC}"
    echo -e "${COLOR_SUCCESS}‚úÖ Backup e restore autom√°tico${NC}"
    echo ""
    echo -e "${COLOR_WARNING}‚ö†Ô∏è  A instala√ß√£o pode levar v√°rios minutos.${NC}"
    echo -e "${COLOR_WARNING}‚ö†Ô∏è  Certifique-se de ter boa conex√£o com a internet.${NC}"
    echo ""
    
    read -p "Deseja continuar com a instala√ß√£o? (s/n): " confirm
    if [ "$confirm" != "s" ] && [ "$confirm" != "S" ]; then
        echo "Instala√ß√£o cancelada."
        exit 0
    fi
    
    # Passo 1: Criar estrutura de diret√≥rios
    log_system "Passo 1/10: Criando estrutura de diret√≥rios..."
    mkdir -p "$MINER_ROOT"
    mkdir -p "$MINER_BIN"
    mkdir -p "$MINER_CONFIG"
    mkdir -p "$MINER_LOGS"
    mkdir -p "$MINER_STATS"
    mkdir -p "$MINER_SCRIPTS"
    mkdir -p "$MINER_BACKUP"
    mkdir -p "$MINER_TEMP"
    mkdir -p "$MINER_CACHE"
    mkdir -p "$MINER_DB"
    mkdir -p "$MINER_WEB"
    mkdir -p "$MINER_API"
    mkdir -p "$MINER_PLUGINS"
    mkdir -p "$MINER_HOOKS"
    mkdir -p "$MINER_JOBS"
    mkdir -p "$MINER_EVENTS"
    mkdir -p "$MINER_ALERTS"
    mkdir -p "$MINER_REPORTS"
    mkdir -p "$MINER_MONITOR"
    mkdir -p "$MINER_OPTIMIZE"
    mkdir -p "$MINER_SECURITY"
    mkdir -p "$MINER_NETWORK"
    mkdir -p "$MINER_HARDWARE"
    mkdir -p "$MINER_REALTIME"
    
    # Inicializar sistema de logs
    init_log_system
    
    # Passo 2: Instalar depend√™ncias
    log_system "Passo 2/10: Instalando depend√™ncias do sistema..."
    pkg update -y > /dev/null 2>&1
    pkg upgrade -y > /dev/null 2>&1
    pkg install -y wget curl tar git python cmake make build-essential libuv libuv-dev libssl-dev libhwloc-dev -y > /dev/null 2>&1
    
    # Passo 3: Instalar XMRig (30 m√©todos)
    log_system "Passo 3/10: Instalando XMRig (30 m√©todos dispon√≠veis)..."
    if ! install_xmrig_complete; then
        log_error "Falha cr√≠tica na instala√ß√£o do XMRig"
        echo "‚ùå A instala√ß√£o falhou. Verifique sua conex√£o com a internet."
        exit 1
    fi
    
    # Passo 4: Criar configura√ß√µes
    log_system "Passo 4/10: Criando configura√ß√µes do sistema..."
    create_configuration
    
    # Passo 5: Configurar monitoramento
    log_system "Passo 5/10: Configurando sistema de monitoramento..."
    start_monitoring_system
    
    # Passo 6: Configurar seguran√ßa
    log_system "Passo 6/10: Configurando sistema de seguran√ßa..."
    setup_security
    
    # Passo 7: Criar scripts b√°sicos
    log_system "Passo 7/10: Criando scripts b√°sicos..."
    
    # Script de in√≠cio de minera√ß√£o
    cat > "$MINER_SCRIPTS/start_mining.sh" << 'EOF'
#!/data/data/com.termux/files/usr/bin/bash
cd /data/data/com.termux/files/home/bitcoin_miner_pro
./bin/xmrig -c config/config.json
EOF
    chmod +x "$MINER_SCRIPTS/start_mining.sh"
    
    # Passo 8: Criar plugins de exemplo
    log_system "Passo 8/10: Criando plugins de exemplo..."
    
    cat > "$MINER_PLUGINS/example_plugin.sh" << 'EOF'
#!/data/data/com.termux/files/usr/bin/bash
# Plugin de exemplo
echo "‚úÖ Plugin de exemplo carregado com sucesso!"
echo "Data: $(date)"
EOF
    chmod +x "$MINER_PLUGINS/example_plugin.sh"
    
    # Passo 9: Backup inicial
    log_system "Passo 9/10: Criando backup inicial do sistema..."
    backup_system
    
    # Passo 10: Iniciar Web Dashboard
    log_system "Passo 10/10: Iniciando Web Dashboard..."
    start_web_dashboard
    
    # Finaliza√ß√£o
    clear
    echo -e "${COLOR_SUCCESS}"
    echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    echo "‚ïë                    INSTALA√á√ÉO CONCLU√çDA COM SUCESSO!                           ‚ïë"
    echo "‚ïë                              SISTEMA PRONTO PARA USO                           ‚ïë"
    echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo -e "${NC}"
    echo ""
    echo -e "${COLOR_INFO}üìÅ Diret√≥rio do sistema:${NC} $MINER_ROOT"
    echo -e "${COLOR_INFO}üí∞ Carteira Bitcoin:${NC} ${BTC_WALLET_MAIN:0:10}..."
    echo -e "${COLOR_INFO}‚ö° XMRig instalado:${NC} $(cat "$MINER_CONFIG/system.info" | grep "XMRIG_VERSION" | cut -d= -f2)"
    echo -e "${COLOR_INFO}üë∑ Worker ID:${NC} $(get_worker_id)"
    echo -e "${COLOR_INFO}üåê Pool padr√£o:${NC} ${POOLS_MAIN[0]}"
    echo -e "${COLOR_INFO}üîë API Key:${NC} ${API_KEY_MAIN:0:8}..."
    echo -e "${COLOR_INFO}üåê API REST:${NC} http://localhost:7777/api/status?api_key=$API_KEY_MAIN"
    echo -e "${COLOR_INFO}‚ö° WebSocket:${NC} ws://localhost:8888"
    echo ""
    echo -e "${COLOR_SUCCESS}‚úÖ Sistema instalado e configurado com sucesso!${NC}"
    echo ""
    echo -e "${COLOR_WARNING}‚ö†Ô∏è  Para iniciar a minera√ß√£o, selecione a op√ß√£o 1 no menu.${NC}"
    echo -e "${COLOR_WARNING}‚ö†Ô∏è  O sistema iniciar√° automaticamente em 10 segundos...${NC}"
    
    # Enviar notifica√ß√£o para Discord
    discord_send "üöÄ **SISTEMA DE MINERA√á√ÉO INSTALADO COM SUCESSO!**\n\n**Worker:** \`$(get_worker_id)\`\n**Vers√£o:** v10.0\n**API:** Dispon√≠vel\n**WebSocket:** Ativo\n**Status:** ‚úÖ Pronto para uso" "3066993" "üéâ INSTALA√á√ÉO CONCLU√çDA"
    
    sleep 10
    
    # Iniciar menu principal
    show_main_menu
}

# ============================================================================
# INICIALIZA√á√ÉO DO SISTEMA
# ============================================================================

# Verificar se o sistema j√° est√° instalado
if [ -d "$MINER_ROOT" ] && [ -f "$MINER_BIN/xmrig" ] && [ -f "$MINER_CONFIG/config.json" ]; then
    log_system "Sistema detectado, iniciando menu principal..."
    show_main_menu
else
    log_system "Sistema n√£o instalado, iniciando instala√ß√£o completa..."
    install_complete_system
fi
