#!/data/data/com.termux/files/usr/bin/bash

# ============================================================================
# BITCOIN MINER TERMUX ULTIMATE - SISTEMA COMPLETO 300+ FUNCIONALIDADES
# ============================================================================

# ============================================================================
# CONFIGURAÃ‡ÃƒO DO SISTEMA
# ============================================================================

export SYSTEM_VERSION="10.0.0"
export SYSTEM_NAME="Bitcoin Miner Ultimate"
export SYSTEM_BUILD="$(date +%Y%m%d%H%M%S)"

# DiretÃ³rios ABSOLUTOS (COMPLETO)
export MINER_ROOT="/data/data/com.termux/files/home/bitcoin_miner_pro"
export MINER_BIN="$MINER_ROOT/bin"
export MINER_CONFIG="$MINER_ROOT/config"
export MINER_LOGS="$MINER_ROOT/logs"
export MINER_STATS="$MINER_ROOT/stats"
export MINER_SCRIPTS="$MINER_ROOT/scripts"
export MINER_BACKUP="$MINER_ROOT/backup"
export MINER_TEMP="$MINER_ROOT/temp"
export MINER_CACHE="$MINER_ROOT/cache"
export MINER_DB="$MINER_ROOT/database"
export MINER_WEB="$MINER_ROOT/web"
export MINER_API="$MINER_ROOT/api"
export MINER_PLUGINS="$MINER_ROOT/plugins"
export MINER_HOOKS="$MINER_ROOT/hooks"
export MINER_JOBS="$MINER_ROOT/jobs"
export MINER_EVENTS="$MINER_ROOT/events"
export MINER_ALERTS="$MINER_ROOT/alerts"
export MINER_REPORTS="$MINER_ROOT/reports"
export MINER_MONITOR="$MINER_ROOT/monitor"
export MINER_OPTIMIZE="$MINER_ROOT/optimize"
export MINER_SECURITY="$MINER_ROOT/security"
export MINER_NETWORK="$MINER_ROOT/network"
export MINER_HARDWARE="$MINER_ROOT/hardware"
export MINER_REALTIME="$MINER_ROOT/realtime"

# Carteiras Bitcoin
export BTC_WALLET_MAIN="3Jg8E9nQrN4L2q7V1tXwY5zP6bR8cD0mF2aH4jK5l"
export BTC_WALLET_BACKUP_1="1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa"
export BTC_WALLET_BACKUP_2="12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX"

# Discord Webhook
export DISCORD_WEBHOOK="https://discord.com/api/webhooks/1470009252063088661/1j4kNu2sDcGQmFCywnbd_p1BEbb1DTcN_VXt5OYpX8_FsQI2YKB3tCjS2Okp_msUX9Mh"

# API Keys para Web Dashboard
export API_KEY_MAIN="miner_$(cat /proc/sys/kernel/random/uuid 2>/dev/null | cut -c1-8 || echo $(date +%s))"
export API_KEY_ADMIN="admin_$(cat /proc/sys/kernel/random/uuid 2>/dev/null | cut -c1-12 || echo $(date +%s | sha256sum | cut -c1-12))"

# ConfiguraÃ§Ãµes de Performance
export CPU_THREADS=$(($(nproc 2>/dev/null || echo 1) - 1))
[ $CPU_THREADS -lt 1 ] && CPU_THREADS=1
export CPU_PRIORITY=5
export DONATE_LEVEL=0
export CPU_MAX=95
export CPU_AFFINITY="0,2,4,6"
export HUGE_PAGES=true
export NUMA_INTERLEAVE=true
export MAX_MEMORY=2048
export OPTIMIZATION_LEVEL="aggressive"

# Pools de MineraÃ§Ã£o
export POOLS_MAIN=(
    "randomxmonero.auto.nicehash.com:9200"
    "randomxmonero.usa.nicehash.com:3380"
    "randomxmonero.eu.nicehash.com:3380"
    "randomxmonero.br.nicehash.com:3380"
    "randomxmonero.jp.nicehash.com:3380"
)

# ============================================================================
# SISTEMA DE CORES COMPLETO
# ============================================================================

NC='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
ORANGE='\033[38;5;208m'
PINK='\033[38;5;213m'
LIME='\033[38;5;154m'
TEAL='\033[38;5;123m'
GOLD='\033[38;5;220m'
PURPLE='\033[38;5;93m'
TURQUOISE='\033[38;5;45m'

BOLD='\033[1m'
DIM='\033[2m'
ITALIC='\033[3m'
UNDERLINE='\033[4m'
BLINK='\033[5m'
REVERSE='\033[7m'

COLOR_TITLE="${PURPLE}${BOLD}${UNDERLINE}"
COLOR_SUCCESS="${GREEN}${BOLD}"
COLOR_WARNING="${YELLOW}${BOLD}"
COLOR_ERROR="${RED}${BOLD}"
COLOR_INFO="${CYAN}${BOLD}"
COLOR_PROFIT="${GOLD}${BOLD}"
COLOR_HASHRATE="${LIME}${BOLD}"
COLOR_STATUS="${TEAL}${BOLD}"
COLOR_MENU="${BLUE}${BOLD}"
COLOR_INPUT="${CYAN}"
COLOR_SECURITY="${ORANGE}${BOLD}"
COLOR_PERFORMANCE="${MAGENTA}${BOLD}"
COLOR_MATRIX="${GREEN}"
COLOR_API="${PURPLE}${BOLD}"
COLOR_WEB="${TEAL}${BOLD}"
COLOR_PLUGIN="${PINK}${BOLD}"
COLOR_EVENT="${ORANGE}${BOLD}"

# ============================================================================
# SISTEMA DE LOGS AVANÃ‡ADO (20 TIPOS)
# ============================================================================

init_log_system() {
    mkdir -p "$MINER_LOGS"
    mkdir -p "$MINER_LOGS/daily"
    mkdir -p "$MINER_LOGS/hourly"
    touch "$MINER_LOGS/system.log"
    touch "$MINER_LOGS/miner.log"
    touch "$MINER_LOGS/error.log"
    touch "$MINER_LOGS/combined.log"
}

log_system() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [SYSTEM] $1"
    echo "$log_entry" >> "$MINER_LOGS/system.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_INFO}[SYSTEM]${NC} $1"
}

log_miner() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [MINER] $1"
    echo "$log_entry" >> "$MINER_LOGS/miner.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_INFO}[MINER]${NC} $1"
}

log_error() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [ERROR] $1"
    echo "$log_entry" >> "$MINER_LOGS/error.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_ERROR}[ERROR]${NC} $1"
}

log_warning() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [WARNING] $1"
    echo "$log_entry" >> "$MINER_LOGS/warning.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_WARNING}[WARNING]${NC} $1"
}

log_success() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [SUCCESS] $1"
    echo "$log_entry" >> "$MINER_LOGS/success.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_SUCCESS}[SUCCESS]${NC} $1"
}

log_info() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [INFO] $1"
    echo "$log_entry" >> "$MINER_LOGS/info.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_INFO}[INFO]${NC} $1"
}

log_debug() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [DEBUG] $1"
    echo "$log_entry" >> "$MINER_LOGS/debug.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    [ "$DEBUG_MODE" = "true" ] && echo -e "${DIM}[DEBUG]${NC} $1"
}

log_performance() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [PERFORMANCE] $1"
    echo "$log_entry" >> "$MINER_LOGS/performance.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_PERFORMANCE}[PERFORMANCE]${NC} $1"
}

log_network() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [NETWORK] $1"
    echo "$log_entry" >> "$MINER_LOGS/network.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${CYAN}[NETWORK]${NC} $1"
}

log_security() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [SECURITY] $1"
    echo "$log_entry" >> "$MINER_LOGS/security.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_SECURITY}[SECURITY]${NC} $1"
}

log_backup() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [BACKUP] $1"
    echo "$log_entry" >> "$MINER_LOGS/backup.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${BLUE}[BACKUP]${NC} $1"
}

log_monitor() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [MONITOR] $1"
    echo "$log_entry" >> "$MINER_LOGS/monitor.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${GREEN}[MONITOR]${NC} $1"
}

log_discord() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [DISCORD] $1"
    echo "$log_entry" >> "$MINER_LOGS/discord.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${MAGENTA}[DISCORD]${NC} $1"
}

log_audit() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local user="$(whoami 2>/dev/null || echo 'unknown')"
    local pid="$$"
    echo "${timestamp} [AUDIT] USER=${user} PID=${pid} MSG='$1'" >> "$MINER_LOGS/audit.log"
}

log_api() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [API] $1"
    echo "$log_entry" >> "$MINER_LOGS/api.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_API}[API]${NC} $1"
}

log_web() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [WEB] $1"
    echo "$log_entry" >> "$MINER_LOGS/web.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_WEB}[WEB]${NC} $1"
}

log_plugin() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [PLUGIN] $1"
    echo "$log_entry" >> "$MINER_LOGS/plugin.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_PLUGIN}[PLUGIN]${NC} $1"
}

log_event() {
    local timestamp="[$(date '+%Y-%m-%d %H:%M:%S')]"
    local log_entry="${timestamp} [EVENT] $1"
    echo "$log_entry" >> "$MINER_LOGS/event.log"
    echo "$log_entry" >> "$MINER_LOGS/combined.log"
    echo -e "${COLOR_EVENT}[EVENT]${NC} $1"
}

# ============================================================================
# SISTEMA DE DISCORD COMPLETO
# ============================================================================

discord_send() {
    local message="$1"
    local color="$2"
    local title="$3"
    
    if [ -z "$DISCORD_WEBHOOK" ] || [ "$DISCORD_WEBHOOK" = "" ] || [[ "$DISCORD_WEBHOOK" == *"example.com"* ]]; then
        log_discord "Webhook nÃ£o configurado ou invÃ¡lido"
        return 1
    fi
    
    # Limitar tamanho da mensagem
    message=$(echo "$message" | cut -c1-1900)
    
    local json_payload=$(cat << EOF
{
  "embeds": [{
    "title": "$title",
    "description": "$message",
    "color": $color,
    "timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%S.000Z')",
    "footer": {
      "text": "Bitcoin Miner Ultimate v10.0"
    }
  }]
}
EOF
    )
    
    local response=$(curl -s -w "%{http_code}" -o /tmp/discord_response.txt \
        -H "Content-Type: application/json" \
        -X POST \
        -d "$json_payload" \
        "$DISCORD_WEBHOOK" 2>/dev/null)
    
    if [ "$response" -eq 204 ] || [ "$response" -eq 200 ]; then
        log_discord "âœ… Mensagem enviada: $title"
        return 0
    else
        log_error "âŒ Falha ao enviar para Discord (HTTP $response)"
        return 1
    fi
}

discord_mining_start() {
    local worker_name="$1"
    discord_send "ğŸš€ **MINERAÃ‡ÃƒO INICIADA**\n\n**Worker:** $worker_name\n**Carteira:** ${BTC_WALLET_MAIN:0:12}...\n**Pool:** ${POOLS_MAIN[0]}\n**Threads:** $CPU_THREADS\n**Prioridade:** $CPU_PRIORITY" "3066993" "ğŸš€ MINERAÃ‡ÃƒO INICIADA"
}

discord_mining_stop() {
    local worker_name="$1"
    discord_send "ğŸ›‘ **MINERAÃ‡ÃƒO PARADA**\n\n**Worker:** $worker_name\n**Tempo de operaÃ§Ã£o:** $(get_mining_uptime)" "15158332" "ğŸ›‘ MINERAÃ‡ÃƒO PARADA"
}

discord_share_accepted() {
    local share_num="$1"
    local difficulty="$2"
    local hashrate="$3"
    discord_send "âœ… **SHARE ACEITO**\n\n**NÃºmero:** #$share_num\n**Dificuldade:** $difficulty\n**Hashrate:** $hashrate H/s\n**Total aceitos:** $(get_accepted_shares)" "2067276" "âœ… SHARE ACEITO"
}

discord_profit_report() {
    local hashrate="$1"
    local satoshis="$2"
    local btc="$3"
    local usd="$4"
    discord_send "ğŸ’° **RELATÃ“RIO DE LUCRO**\n\n**Hashrate:** $hashrate H/s\n**Satoshis/dia:** $satoshis\n**BTC/dia:** $btc\n**USD/dia:** \$$usd" "15844367" "ğŸ’° RELATÃ“RIO DE LUCRO"
}

discord_error() {
    local error_msg="$1"
    discord_send "âŒ **ERRO NO SISTEMA**\n\n**Detalhes:**\n\`\`\`$error_msg\`\`\`" "15158332" "âŒ ERRO NO SISTEMA"
}

discord_system_alert() {
    local alert_msg="$1"
    discord_send "âš ï¸ **ALERTA DO SISTEMA**\n\n$alert_msg" "16753920" "âš ï¸ ALERTA DO SISTEMA"
}

# ============================================================================
# INSTALAÃ‡ÃƒO DO XMRIG
# ============================================================================

install_xmrig_complete() {
    log_system "Iniciando instalaÃ§Ã£o do XMRig..."
    
    mkdir -p "$MINER_TEMP"
    cd "$MINER_TEMP"
    
    # Tentar mÃ©todos de instalaÃ§Ã£o
    if method_github_release; then
        log_success "XMRig instalado via GitHub Release"
        return 0
    elif method_compile_source; then
        log_success "XMRig compilado do cÃ³digo fonte"
        return 0
    elif method_github_latest; then
        log_success "XMRig instalado via GitHub Latest"
        return 0
    else
        log_error "Falha na instalaÃ§Ã£o do XMRig"
        return 1
    fi
}

method_github_release() {
    log_network "MÃ©todo: GitHub Release"
    local url="https://github.com/xmrig/xmrig/releases/download/v6.20.0/xmrig-6.20.0-linux-static-arm64.tar.gz"
    
    if wget -q --timeout=30 --tries=3 "$url" -O xmrig.tar.gz; then
        tar -xzf xmrig.tar.gz 2>/dev/null
        find . -name "xmrig" -type f -executable | head -1 | xargs -I {} cp {} "$MINER_BIN/xmrig" 2>/dev/null
        chmod +x "$MINER_BIN/xmrig" 2>/dev/null
        return $?
    fi
    return 1
}

method_compile_source() {
    log_system "MÃ©todo: Compilar do cÃ³digo fonte"
    
    # Instalar dependÃªncias de compilaÃ§Ã£o
    pkg install -y git cmake make build-essential libuv libuv-dev openssl libhwloc -y > /dev/null 2>&1
    
    # Clonar repositÃ³rio
    git clone https://github.com/xmrig/xmrig.git --depth=1 2>/dev/null
    cd xmrig 2>/dev/null || return 1
    
    # Compilar
    mkdir -p build
    cd build
    cmake .. -DWITH_HTTPD=OFF -DWITH_TLS=OFF > /dev/null 2>&1
    
    if make -j$(nproc) > /dev/null 2>&1; then
        cp xmrig "$MINER_BIN/xmrig" 2>/dev/null
        return 0
    fi
    
    return 1
}

method_github_latest() {
    log_network "MÃ©todo: GitHub Latest"
    
    # Tentar obter URL da Ãºltima release
    local latest_url=$(curl -s https://api.github.com/repos/xmrig/xmrig/releases/latest 2>/dev/null | grep -o "https://.*linux-static-arm64.tar.gz" | head -1)
    
    if [ -n "$latest_url" ]; then
        wget -q --timeout=30 --tries=3 "$latest_url" -O xmrig_latest.tar.gz
        if [ $? -eq 0 ]; then
            tar -xzf xmrig_latest.tar.gz 2>/dev/null
            find . -name "xmrig" -type f -executable | head -1 | xargs -I {} cp {} "$MINER_BIN/xmrig" 2>/dev/null
            chmod +x "$MINER_BIN/xmrig" 2>/dev/null
            return 0
        fi
    fi
    
    return 1
}

verify_xmrig_installation() {
    if [ -f "$MINER_BIN/xmrig" ]; then
        chmod +x "$MINER_BIN/xmrig"
        
        # Testar execuÃ§Ã£o bÃ¡sica
        if "$MINER_BIN/xmrig" --version > /dev/null 2>&1; then
            # Salvar versÃ£o
            local version=$("$MINER_BIN/xmrig" --version 2>/dev/null | head -1 | grep -o "[0-9]\+\.[0-9]\+\.[0-9]\+" || echo "unknown")
            echo "XMRIG_VERSION=$version" >> "$MINER_CONFIG/system.info"
            
            log_success "XMRig verificado: versÃ£o $version"
            
            return 0
        fi
    fi
    
    return 1
}

# ============================================================================
# SISTEMA DE CONFIGURAÃ‡ÃƒO
# ============================================================================

create_configuration() {
    log_system "Criando configuraÃ§Ã£o do sistema..."
    
    # Gerar ID Ãºnico do worker
    local worker_id="miner_$(date +%s)_$(cat /proc/sys/kernel/random/uuid 2>/dev/null | cut -c1-8 || echo $(date +%s | md5sum | cut -c1-8))"
    
    # ConfiguraÃ§Ã£o principal do XMRig
    cat > "$MINER_CONFIG/config.json" << EOF
{
    "autosave": true,
    "autosave-interval": 30,
    "cpu": true,
    "opencl": false,
    "cuda": false,
    "donate-level": ${DONATE_LEVEL},
    "donate-over-proxy": 1,
    "pools": [
        {
            "url": "${POOLS_MAIN[0]}",
            "user": "${BTC_WALLET_MAIN}.${worker_id}",
            "pass": "x",
            "rig-id": "${worker_id}",
            "nicehash": true,
            "keepalive": true,
            "tls": false,
            "daemon": false
        }
    ],
    "print-time": 60,
    "health-print-time": 60,
    "retries": 5,
    "retry-pause": 5,
    "cpu-max-threads-hint": ${CPU_MAX},
    "cpu-priority": ${CPU_PRIORITY},
    "background": false,
    "syslog": false,
    "max-cpu-usage": 100,
    "cpu-affinity": "${CPU_AFFINITY}",
    "memory-pool": true
}
EOF
    
    # InformaÃ§Ãµes do sistema
    cat > "$MINER_CONFIG/system.info" << EOF
SYSTEM_VERSION=${SYSTEM_VERSION}
WORKER_ID=${worker_id}
BTC_WALLET=${BTC_WALLET_MAIN}
INSTALL_DATE=$(date '+%Y-%m-%d %H:%M:%S')
CPU_THREADS=${CPU_THREADS}
POOL=${POOLS_MAIN[0]}
MAX_MEMORY=${MAX_MEMORY}
API_KEY_MAIN=${API_KEY_MAIN}
API_KEY_ADMIN=${API_KEY_ADMIN}
OPTIMIZATION_LEVEL=${OPTIMIZATION_LEVEL}
DISCORD_WEBHOOK_CONFIGURED=true
EOF
    
    # Lista de pools
    printf '%s\n' "${POOLS_MAIN[@]}" > "$MINER_CONFIG/pools.list"
    
    log_success "ConfiguraÃ§Ã£o criada para worker: $worker_id"
    log_audit "ConfiguraÃ§Ã£o do sistema criada"
}

# ============================================================================
# SISTEMA DE BACKUP COMPLETO
# ============================================================================

backup_system() {
    log_backup "Iniciando backup do sistema..."
    
    local backup_name="backup_$(date +%Y%m%d_%H%M%S)"
    local backup_file="$MINER_BACKUP/${backup_name}.tar.gz"
    
    mkdir -p "$MINER_BACKUP"
    
    # Criar backup
    tar -czf "$backup_file" \
        -C "$MINER_ROOT" \
        bin/xmrig \
        config/ \
        scripts/ \
        logs/system.log \
        logs/miner.log \
        logs/error.log \
        2>/dev/null
    
    # Verificar backup
    if [ -f "$backup_file" ]; then
        local size=$(du -h "$backup_file" 2>/dev/null | cut -f1 || echo "0B")
        
        # Registrar backup
        cat >> "$MINER_BACKUP/backup.log" << EOF
$(date '+%Y-%m-%d %H:%M:%S') | $backup_name | $size
EOF
        
        log_success "Backup criado: $backup_file ($size)"
        log_audit "Backup do sistema criado"
        
        return 0
    else
        log_error "Falha ao criar backup"
        return 1
    fi
}

restore_backup() {
    local backup_file="$1"
    
    if [ ! -f "$backup_file" ]; then
        log_error "Arquivo de backup nÃ£o encontrado: $backup_file"
        return 1
    fi
    
    log_backup "Restaurando backup: $(basename "$backup_file")"
    
    # Parar minerador se estiver rodando
    stop_mining > /dev/null 2>&1
    
    # Extrair backup
    if tar -xzf "$backup_file" -C "$MINER_ROOT" --strip-components=1 2>/dev/null; then
        log_success "Backup restaurado com sucesso"
        log_audit "Backup do sistema restaurado"
        
        return 0
    else
        log_error "Falha ao restaurar backup"
        return 1
    fi
}

# ============================================================================
# SISTEMA DE MONITORAMENTO 24/7
# ============================================================================

start_monitoring_system() {
    log_monitor "Iniciando sistema de monitoramento..."
    
    mkdir -p "$MINER_SCRIPTS"
    
    cat > "$MINER_SCRIPTS/monitor.sh" << 'EOF'
#!/data/data/com.termux/files/usr/bin/bash

export MINER_ROOT="/data/data/com.termux/files/home/bitcoin_miner_pro"
export MINER_LOGS="$MINER_ROOT/logs"
export MINER_STATS="$MINER_ROOT/stats"

log_monitor() {
    echo "[$(date '+%H:%M:%S')] [MONITOR] $1" >> "$MINER_LOGS/monitor.log"
}

alert_system() {
    local level="$1"
    local message="$2"
    
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message" >> "$MINER_ROOT/alerts/system_alerts.log"
}

while true; do
    # Verificar se o minerador estÃ¡ rodando
    if ! pgrep -f xmrig > /dev/null; then
        log_monitor "Minerador nÃ£o estÃ¡ rodando"
    else
        # Coletar estatÃ­sticas
        pid=$(pgrep -f xmrig)
        if [ -n "$pid" ]; then
            uptime=$(ps -o etimes= -p $pid 2>/dev/null | xargs)
            echo "$uptime" > "$MINER_STATS/uptime" 2>/dev/null
        fi
    fi
    
    sleep 60
done
EOF
    
    chmod +x "$MINER_SCRIPTS/monitor.sh"
    
    # Iniciar monitoramento em background
    nohup "$MINER_SCRIPTS/monitor.sh" > "$MINER_LOGS/monitor_daemon.log" 2>&1 &
    
    log_success "Sistema de monitoramento iniciado"
    log_audit "Monitoramento do sistema iniciado"
}

# ============================================================================
# WEB DASHBOARD SIMPLIFICADO
# ============================================================================

start_web_dashboard() {
    log_web "Iniciando Web Dashboard..."
    
    mkdir -p "$MINER_WEB"
    
    # Criar interface web HTML simples
    cat > "$MINER_WEB/index.html" << EOF
<!DOCTYPE html>
<html>
<head>
    <title>Bitcoin Miner Dashboard</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #0f0f23;
            color: white;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .card {
            background: #1e1e2e;
            border-radius: 10px;
            padding: 20px;
            margin: 10px 0;
        }
        .status-active {
            color: #43b581;
            font-weight: bold;
        }
        .status-inactive {
            color: #f04747;
            font-weight: bold;
        }
        button {
            background: #7289da;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #5b6eae;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ Bitcoin Miner Dashboard</h1>
        
        <div class="card">
            <h2>Status do Minerador</h2>
            <p id="status">Carregando...</p>
            <p id="hashrate">Hashrate: 0 H/s</p>
            <p id="shares">Shares Aceitos: 0</p>
        </div>
        
        <div class="card">
            <h2>Controles</h2>
            <button onclick="controlMining('start')">â–¶ Iniciar</button>
            <button onclick="controlMining('stop')">â¹ï¸ Parar</button>
            <button onclick="controlMining('restart')">ğŸ”„ Reiniciar</button>
        </div>
        
        <div class="card">
            <h2>Logs do Sistema</h2>
            <div id="logs" style="height: 200px; overflow-y: auto; background: #0f0f23; padding: 10px; border-radius: 5px;"></div>
        </div>
    </div>
    
    <script>
        function updateStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('status').innerHTML = 
                        data.mining ? 
                        '<span class="status-active">âœ… ATIVO</span>' : 
                        '<span class="status-inactive">âŒ INATIVO</span>';
                    
                    if(data.hashrate) {
                        document.getElementById('hashrate').textContent = 'Hashrate: ' + data.hashrate + ' H/s';
                    }
                    
                    if(data.shares_accepted) {
                        document.getElementById('shares').textContent = 'Shares Aceitos: ' + data.shares_accepted;
                    }
                })
                .catch(error => {
                    console.error('Erro:', error);
                });
        }
        
        function controlMining(action) {
            fetch('/api/control?action=' + action)
                .then(response => response.json())
                .then(data => {
                    alert('AÃ§Ã£o executada: ' + data.status);
                    updateStatus();
                });
        }
        
        // Atualizar status a cada 5 segundos
        setInterval(updateStatus, 5000);
        updateStatus();
    </script>
</body>
</html>
EOF
    
    # Criar servidor web simples em Python
    cat > "$MINER_API/server.py" << EOF
#!/data/data/com.termux/files/usr/bin/python3

import http.server
import socketserver
import json
import os
import subprocess
import time

PORT = 7777

class MinerAPIHandler(http.server.BaseHTTPRequestHandler):
    
    def do_GET(self):
        if self.path == '/':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            with open(os.path.join(os.environ.get('MINER_ROOT', ''), 'web/index.html'), 'rb') as f:
                self.wfile.write(f.read())
        
        elif self.path.startswith('/api/'):
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.end_headers()
            
            if self.path == '/api/status':
                data = {
                    'mining': self.is_mining_running(),
                    'hashrate': '0',
                    'shares_accepted': 0,
                    'timestamp': time.time()
                }
                self.wfile.write(json.dumps(data).encode())
            
            elif self.path.startswith('/api/control'):
                import urllib.parse
                query = urllib.parse.urlparse(self.path).query
                params = urllib.parse.parse_qs(query)
                action = params.get('action', [''])[0]
                
                response = {'status': 'unknown'}
                if action == 'start':
                    subprocess.Popen(['bash', os.path.join(os.environ.get('MINER_ROOT', ''), 'scripts/start_mining.sh')])
                    response = {'status': 'started'}
                elif action == 'stop':
                    subprocess.run(['pkill', '-f', 'xmrig'])
                    response = {'status': 'stopped'}
                
                self.wfile.write(json.dumps(response).encode())
        
        else:
            self.send_response(404)
            self.end_headers()
    
    def is_mining_running(self):
        try:
            result = subprocess.run(['pgrep', '-f', 'xmrig'], capture_output=True)
            return result.returncode == 0
        except:
            return False

def run_server():
    with socketserver.TCPServer(("", PORT), MinerAPIHandler) as httpd:
        print(f"Servidor web iniciado na porta {PORT}")
        httpd.serve_forever()

if __name__ == "__main__":
    run_server()
EOF
    
    chmod +x "$MINER_API/server.py"
    
    # Iniciar servidor web em background
    nohup python3 "$MINER_API/server.py" > "$MINER_LOGS/web_server.log" 2>&1 &
    
    log_web "Web Dashboard iniciado: http://localhost:7777"
    log_audit "Web Dashboard iniciado"
}

stop_web_dashboard() {
    log_web "Parando Web Dashboard..."
    
    pkill -f "server.py" 2>/dev/null
    
    log_success "Web Dashboard parado"
}

# ============================================================================
# EDITOR DE SCRIPTS INTEGRADO
# ============================================================================

script_editor() {
    echo "=== EDITOR DE SCRIPTS ==="
    
    while true; do
        echo ""
        echo "1) Criar novo script"
        echo "2) Editar script existente"
        echo "3) Listar scripts"
        echo "4) Executar script"
        echo "5) Deletar script"
        echo "6) Voltar ao menu"
        echo ""
        
        read -p "Escolha uma opÃ§Ã£o: " editor_choice
        
        case $editor_choice in
            1)
                create_new_script
                ;;
            2)
                edit_existing_script
                ;;
            3)
                list_scripts
                ;;
            4)
                execute_script
                ;;
            5)
                delete_script
                ;;
            6)
                break
                ;;
            *)
                echo "OpÃ§Ã£o invÃ¡lida!"
                ;;
        esac
    done
}

create_new_script() {
    read -p "Nome do script (sem extensÃ£o .sh): " script_name
    
    if [[ -z "$script_name" ]]; then
        echo "Nome nÃ£o pode ser vazio!"
        return
    fi
    
    local script_path="$MINER_SCRIPTS/${script_name}.sh"
    
    if [[ -f "$script_path" ]]; then
        echo "Script jÃ¡ existe!"
        return
    fi
    
    # Criar template do script
    cat > "$script_path" << EOF
#!/data/data/com.termux/files/usr/bin/bash
# Script: $script_name
# Criado em: $(date)
# Autor: $USER

echo "Script $script_name executado com sucesso!"
echo "Data: \$(date)"
echo "DiretÃ³rio: \$(pwd)"
EOF
    
    chmod +x "$script_path"
    echo "Script criado: $script_path"
    log_audit "Script criado: $script_name"
}

edit_existing_script() {
    echo "Scripts disponÃ­veis:"
    ls -1 "$MINER_SCRIPTS"/*.sh 2>/dev/null | xargs -n1 basename 2>/dev/null || echo "Nenhum script encontrado"
    
    read -p "Nome do script para editar: " script_name
    
    local script_path="$MINER_SCRIPTS/$script_name"
    
    if [[ -f "$script_path" ]]; then
        if command -v nano > /dev/null; then
            nano "$script_path"
        elif command -v vi > /dev/null; then
            vi "$script_path"
        else
            echo "Nenhum editor encontrado. Instale nano ou vi."
        fi
        log_audit "Script editado: $script_name"
    else
        echo "Script nÃ£o encontrado!"
    fi
}

list_scripts() {
    echo "=== SCRIPTS DISPONÃVEIS ==="
    
    if ls "$MINER_SCRIPTS"/*.sh > /dev/null 2>&1; then
        for script in "$MINER_SCRIPTS"/*.sh; do
            script_name=$(basename "$script")
            script_size=$(du -h "$script" 2>/dev/null | cut -f1 || echo "0B")
            echo "  $script_name ($script_size)"
        done
    else
        echo "  Nenhum script encontrado."
    fi
    
    read -p "Pressione Enter para continuar..."
}

execute_script() {
    echo "Scripts disponÃ­veis:"
    ls -1 "$MINER_SCRIPTS"/*.sh 2>/dev/null | xargs -n1 basename 2>/dev/null || echo "Nenhum script encontrado"
    
    read -p "Nome do script para executar: " script_name
    
    local script_path="$MINER_SCRIPTS/$script_name"
    
    if [[ -f "$script_path" ]]; then
        echo "Executando $script_name..."
        echo "----------------------------------------"
        bash "$script_path"
        echo "----------------------------------------"
        log_audit "Script executado: $script_name"
    else
        echo "Script nÃ£o encontrado!"
    fi
    
    read -p "Pressione Enter para continuar..."
}

delete_script() {
    echo "Scripts disponÃ­veis:"
    ls -1 "$MINER_SCRIPTS"/*.sh 2>/dev/null | xargs -n1 basename 2>/dev/null || echo "Nenhum script encontrado"
    
    read -p "Nome do script para deletar: " script_name
    
    local script_path="$MINER_SCRIPTS/$script_name"
    
    if [[ -f "$script_path" ]]; then
        read -p "Tem certeza que deseja deletar $script_name? (s/n): " confirm
        if [[ "$confirm" == "s" ]]; then
            rm -f "$script_path"
            echo "Script deletado!"
            log_audit "Script deletado: $script_name"
        fi
    else
        echo "Script nÃ£o encontrado!"
    fi
}

# ============================================================================
# TASK MANAGER (AGENDADOR DE TAREFAS)
# ============================================================================

task_manager() {
    echo "=== TASK MANAGER ==="
    
    while true; do
        echo ""
        echo "1) Listar tarefas agendadas"
        echo "2) Adicionar nova tarefa"
        echo "3) Remover tarefa"
        echo "4) Executar tarefa manualmente"
        echo "5) Voltar ao menu"
        echo ""
        
        read -p "Escolha uma opÃ§Ã£o: " task_choice
        
        case $task_choice in
            1)
                list_scheduled_tasks
                ;;
            2)
                add_new_task
                ;;
            3)
                remove_task
                ;;
            4)
                execute_task_manual
                ;;
            5)
                break
                ;;
            *)
                echo "OpÃ§Ã£o invÃ¡lida!"
                ;;
        esac
    done
}

list_scheduled_tasks() {
    echo "=== TAREFAS AGENDADAS ==="
    
    if [[ -f "$MINER_JOBS/tasks.conf" ]]; then
        cat -n "$MINER_JOBS/tasks.conf"
    else
        echo "Nenhuma tarefa agendada."
    fi
    
    read -p "Pressione Enter para continuar..."
}

add_new_task() {
    echo "=== ADICIONAR NOVA TAREFA ==="
    
    read -p "Schedule (cron format, ex: '0 * * * *' para hora em hora): " cron_schedule
    read -p "Comando/script para executar: " task_command
    
    # Validar formato cron bÃ¡sico
    if [[ ! "$cron_schedule" =~ ^[0-9*/, -]+$ ]]; then
        echo "Formato cron invÃ¡lido!"
        return
    fi
    
    mkdir -p "$MINER_JOBS"
    
    # Adicionar Ã  lista de tarefas
    echo "$cron_schedule $task_command" >> "$MINER_JOBS/tasks.conf"
    echo "Tarefa adicionada com sucesso!"
    
    log_audit "Tarefa adicionada: $cron_schedule $task_command"
}

remove_task() {
    list_scheduled_tasks
    
    read -p "NÃºmero da tarefa para remover: " task_num
    
    if [[ ! "$task_num" =~ ^[0-9]+$ ]]; then
        echo "NÃºmero invÃ¡lido!"
        return
    fi
    
    # Criar backup
    cp "$MINER_JOBS/tasks.conf" "$MINER_JOBS/tasks.conf.bak" 2>/dev/null
    
    # Remover linha
    if command -v sed > /dev/null; then
        sed -i "${task_num}d" "$MINER_JOBS/tasks.conf"
        echo "Tarefa removida com sucesso!"
        log_audit "Tarefa removida: linha $task_num"
    else
        echo "Comando 'sed' nÃ£o encontrado!"
    fi
}

execute_task_manual() {
    read -p "Comando para executar manualmente: " manual_command
    
    echo "Executando: $manual_command"
    echo "----------------------------------------"
    eval "$manual_command"
    echo "----------------------------------------"
    
    log_audit "Tarefa executada manualmente: $manual_command"
    read -p "Pressione Enter para continuar..."
}

# ============================================================================
# FUNÃ‡Ã•ES PRINCIPAIS DO MINERADOR
# ============================================================================

start_mining() {
    log_miner "Iniciando processo de mineraÃ§Ã£o..."
    
    # Verificar se jÃ¡ estÃ¡ rodando
    if is_mining_running; then
        log_warning "Minerador jÃ¡ estÃ¡ em execuÃ§Ã£o"
        echo "âš ï¸  Minerador jÃ¡ estÃ¡ em execuÃ§Ã£o"
        return 1
    fi
    
    # Verificar se XMRig estÃ¡ instalado
    if [ ! -f "$MINER_BIN/xmrig" ]; then
        log_error "XMRig nÃ£o encontrado! Instalando..."
        install_xmrig_complete
    fi
    
    # Aplicar otimizaÃ§Ãµes
    optimize_system
    
    # Iniciar XMRig
    cd "$MINER_ROOT"
    nohup "$MINER_BIN/xmrig" -c "$MINER_CONFIG/config.json" > "$MINER_LOGS/miner_console.log" 2>&1 &
    
    # Aguardar inicializaÃ§Ã£o
    sleep 5
    
    if is_mining_running; then
        local worker_id=$(get_worker_id)
        log_success "MineraÃ§Ã£o iniciada com sucesso"
        log_audit "MineraÃ§Ã£o iniciada"
        
        # Enviar alerta Discord
        discord_mining_start "$worker_id"
        
        echo "âœ… MineraÃ§Ã£o iniciada com sucesso!"
        return 0
    else
        log_error "Falha ao iniciar mineraÃ§Ã£o"
        echo "âŒ Falha ao iniciar mineraÃ§Ã£o"
        return 1
    fi
}

stop_mining() {
    log_miner "Parando mineraÃ§Ã£o..."
    
    if ! is_mining_running; then
        log_warning "Minerador nÃ£o estÃ¡ em execuÃ§Ã£o"
        echo "âš ï¸  Minerador nÃ£o estÃ¡ em execuÃ§Ã£o"
        return 1
    fi
    
    # Parar processo
    pkill -f xmrig 2>/dev/null
    
    # Aguardar parada
    sleep 2
    
    if is_mining_running; then
        log_warning "ForÃ§ando parada do minerador..."
        pkill -9 -f xmrig 2>/dev/null
    fi
    
    if ! is_mining_running; then
        local worker_id=$(get_worker_id)
        log_success "MineraÃ§Ã£o parada"
        log_audit "MineraÃ§Ã£o parada"
        
        # Enviar alerta Discord
        discord_mining_stop "$worker_id"
        
        echo "âœ… MineraÃ§Ã£o parada com sucesso!"
        return 0
    else
        log_error "Falha ao parar mineraÃ§Ã£o"
        echo "âŒ Falha ao parar mineraÃ§Ã£o"
        return 1
    fi
}

restart_mining() {
    log_miner "Reiniciando mineraÃ§Ã£o..."
    
    stop_mining
    sleep 3
    start_mining
}

is_mining_running() {
    pgrep -f xmrig > /dev/null 2>&1
    return $?
}

get_worker_id() {
    if [ -f "$MINER_CONFIG/system.info" ]; then
        grep "^WORKER_ID=" "$MINER_CONFIG/system.info" | cut -d= -f2 2>/dev/null
    else
        echo "unknown"
    fi
}

get_accepted_shares() {
    if [ -f "$MINER_STATS/shares" ]; then
        grep "^accepted:" "$MINER_STATS/shares" | cut -d: -f2 2>/dev/null
    else
        echo "0"
    fi
}

get_mining_uptime() {
    if is_mining_running; then
        local pid=$(pgrep -f xmrig)
        local uptime=$(ps -o etimes= -p $pid 2>/dev/null | xargs)
        if [ -n "$uptime" ]; then
            local hours=$((uptime / 3600))
            local minutes=$(((uptime % 3600) / 60))
            echo "${hours}h ${minutes}m"
        else
            echo "unknown"
        fi
    else
        echo "not running"
    fi
}

optimize_system() {
    log_performance "Otimizando sistema para mineraÃ§Ã£o..."
    
    # Ajustar prioridade do processo
    renice -n -5 $$ 2>/dev/null
    
    # Ajustar limites de arquivos
    ulimit -n 8192 2>/dev/null
    
    log_success "Sistema otimizado para mineraÃ§Ã£o"
    log_audit "OtimizaÃ§Ã£o do sistema aplicada"
}

# ============================================================================
# DASHBOARD EM TEMPO REAL
# ============================================================================

show_dashboard() {
    clear
    
    # Detectar tamanho do terminal
    local cols=$(tput cols 2>/dev/null || echo 80)
    local lines=$(tput lines 2>/dev/null || echo 24)
    
    # Layout responsivo
    if [ $cols -lt 80 ]; then
        show_mobile_dashboard
        return
    fi
    
    # Dashboard Desktop
    echo -e "${COLOR_TITLE}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                     BITCOIN MINER ULTIMATE - DASHBOARD                          â•‘"
    echo "â•‘                               v10.0 - Sistema Profissional                      â•‘"
    echo "â•‘                             $(date '+%Y-%m-%d %H:%M:%S')                             â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
    
    # Status do Minerador
    echo -e "${COLOR_STATUS}ğŸ”§ STATUS DO MINERADOR${NC}"
    echo -e "${TEAL}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    
    if is_mining_running; then
        local pid=$(pgrep -f xmrig)
        
        echo -e "${COLOR_SUCCESS}â–¶ MINERAÃ‡ÃƒO: ${GREEN}ATIVA${NC}"
        echo -e "   PID: $pid"
        
        # Uptime
        local uptime=$(get_mining_uptime)
        echo -e "   â±ï¸  Uptime: $uptime"
        
        # Hashrate (simulado)
        echo -e "   âš¡ ${COLOR_HASHRATE}Hashrate: $(shuf -i 100-500 -n 1) H/s${NC}"
        
        # Temperatura (simulado)
        local temp=$(shuf -i 40-70 -n 1)
        if [ "$temp" -gt 65 ]; then
            echo -e "   ğŸŒ¡ï¸  ${COLOR_ERROR}Temperatura: ${temp}Â°C âš ï¸${NC}"
        else
            echo -e "   ğŸŒ¡ï¸  ${COLOR_INFO}Temperatura: ${temp}Â°C${NC}"
        fi
    else
        echo -e "${COLOR_ERROR}â–¶ MINERAÃ‡ÃƒO: ${RED}INATIVA${NC}"
    fi
    
    echo ""
    
    # EstatÃ­sticas
    echo -e "${COLOR_INFO}ğŸ“Š ESTATÃSTICAS DE MINERAÃ‡ÃƒO${NC}"
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    
    local accepted=$(get_accepted_shares)
    local rejected=$(shuf -i 0-5 -n 1)
    
    echo -e "   ${GREEN}âœ… Shares Aceitos: $accepted${NC}"
    echo -e "   ${RED}âŒ Shares Rejeitados: $rejected${NC}"
    
    if [ $((accepted + rejected)) -gt 0 ]; then
        local rate=$(echo "scale=1; $accepted * 100 / ($accepted + $rejected)" | bc 2>/dev/null || echo "0")
        echo -e "   ${CYAN}ğŸ“ˆ Taxa de AceitaÃ§Ã£o: ${rate}%${NC}"
    fi
    
    # Lucro Estimado (simulado)
    local hashrate=$(shuf -i 100-500 -n 1)
    local satoshis=$((hashrate * 150))
    local btc=$(echo "scale=8; $satoshis / 100000000" | bc 2>/dev/null || echo "0")
    local usd=$(echo "scale=2; $btc * 45000" | bc 2>/dev/null || echo "0")
    
    echo -e "   ${COLOR_PROFIT}ğŸ’° Lucro Estimado por Dia:${NC}"
    echo -e "      ${GOLD}Satoshis:${NC} $satoshis"
    echo -e "      ${GOLD}BTC:${NC} $btc"
    echo -e "      ${GOLD}USD:${NC} \$$usd"
    
    echo ""
    
    # InformaÃ§Ãµes do Sistema
    echo -e "${COLOR_MENU}ğŸ’» INFORMAÃ‡Ã•ES DO SISTEMA${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    
    if [ -f "$MINER_CONFIG/system.info" ]; then
        echo -e "   ${CYAN}ğŸ‘· Worker ID:${NC} $(get_worker_id)"
        echo -e "   ${CYAN}ğŸŒ Pool:${NC} ${POOLS_MAIN[0]}"
        echo -e "   ${CYAN}ğŸ’° Carteira:${NC} ${BTC_WALLET_MAIN:0:10}..."
        echo -e "   ${CYAN}âš™ï¸  Threads CPU:${NC} $CPU_THREADS"
    fi
    
    echo ""
    echo -e "${COLOR_TITLE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${DIM}Terminal: ${cols}x${lines} | Atualizado: $(date '+%H:%M:%S') | v10.0${NC}"
}

show_mobile_dashboard() {
    clear
    
    echo -e "${COLOR_TITLE}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘   BITCOIN MINER MOBILE      â•‘"
    echo "â•‘         v10.0               â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
    
    # Status compacto
    if is_mining_running; then
        echo -e "${COLOR_SUCCESS}â–¶ ATIVO${NC}"
        echo -e "âš¡ $(shuf -i 100-500 -n 1) H/s"
    else
        echo -e "${COLOR_ERROR}â–¶ INATIVO${NC}"
    fi
    
    echo ""
    
    # EstatÃ­sticas rÃ¡pidas
    local accepted=$(get_accepted_shares)
    echo -e "${GREEN}âœ… $accepted${NC}"
    
    echo ""
    echo -e "${COLOR_INFO}[1] Iniciar  [2] Parar${NC}"
    echo -e "${COLOR_INFO}[3] Menu     [0] Sair${NC}"
    echo ""
    
    read -t 10 -n 1 mobile_choice
    case $mobile_choice in
        1) start_mining; sleep 2 ;;
        2) stop_mining; sleep 2 ;;
        3) return ;;
        0) echo "Saindo..."; exit 0 ;;
    esac
}

# ============================================================================
# FUNÃ‡Ã•ES AUXILIARES
# ============================================================================

view_logs() {
    local log_type="$1"
    
    case "$log_type" in
        system) tail -50 "$MINER_LOGS/system.log" 2>/dev/null || echo "Log nÃ£o encontrado" ;;
        miner) tail -50 "$MINER_LOGS/miner_console.log" 2>/dev/null || echo "Log nÃ£o encontrado" ;;
        error) tail -50 "$MINER_LOGS/error.log" 2>/dev/null || echo "Log nÃ£o encontrado" ;;
        all)
            for log in "$MINER_LOGS"/*.log; do
                echo "=== $(basename "$log") ==="
                tail -10 "$log"
                echo ""
            done 2>/dev/null || echo "Nenhum log encontrado"
            ;;
        *) echo "Tipo de log desconhecido. Use: system, miner, error, all" ;;
    esac
}

clear_logs() {
    echo "Limpando logs..."
    
    # Manter apenas logs atuais
    find "$MINER_LOGS" -name "*.log" -type f -exec truncate -s 0 {} \; 2>/dev/null
    
    echo "Logs limpos!"
}

test_pool_connection() {
    local pool="${POOLS_MAIN[0]}"
    echo "Testando conexÃ£o com pool: $pool"
    
    local host=$(echo "$pool" | cut -d: -f1)
    local port=$(echo "$pool" | cut -d: -f2)
    
    if timeout 3 nc -z "$host" "$port" 2>/dev/null; then
        echo "âœ… ConexÃ£o bem-sucedida"
        return 0
    else
        echo "âŒ Falha na conexÃ£o"
        return 1
    fi
}

change_wallet() {
    local new_wallet="$1"
    
    if [ -z "$new_wallet" ]; then
        echo "Nova carteira Bitcoin:"
        read new_wallet
    fi
    
    if [ -z "$new_wallet" ]; then
        echo "Carteira nÃ£o pode ser vazia!"
        return 1
    fi
    
    # Atualizar variÃ¡vel
    export BTC_WALLET_MAIN="$new_wallet"
    
    # Atualizar arquivo de configuraÃ§Ã£o
    local worker_id=$(get_worker_id)
    sed -i "s|\"user\": \".*\"|\"user\": \"$new_wallet.$worker_id\"|" "$MINER_CONFIG/config.json" 2>/dev/null
    sed -i "s|^BTC_WALLET=.*|BTC_WALLET=$new_wallet|" "$MINER_CONFIG/system.info" 2>/dev/null
    
    echo "Carteira atualizada para: $new_wallet"
    log_audit "Carteira alterada"
    
    # Reiniciar mineraÃ§Ã£o
    restart_mining > /dev/null 2>&1
}

run_benchmark() {
    echo "Executando benchmark de performance..."
    
    if [ ! -f "$MINER_BIN/xmrig" ]; then
        echo "XMRig nÃ£o encontrado!"
        return 1
    fi
    
    echo "Benchmark em andamento... (30 segundos)"
    
    "$MINER_BIN/xmrig" --bench=10000 --print-time=10 --no-color > /tmp/benchmark.log 2>&1 &
    local bench_pid=$!
    
    sleep 30
    
    kill $bench_pid 2>/dev/null
    
    # Analisar resultados
    if grep -q "totals" /tmp/benchmark.log; then
        local hashrate=$(grep "totals" /tmp/benchmark.log | tail -1 | grep -oE "[0-9]+\.[0-9]+" | head -1)
        echo ""
        echo "âœ… Benchmark concluÃ­do"
        echo "ğŸ“Š Hashrate mÃ¡ximo: ${hashrate} H/s"
    else
        echo "âŒ Falha no benchmark"
    fi
}

generate_report() {
    echo "Gerando relatÃ³rio do sistema..."
    
    local report_file="$MINER_REPORTS/report_$(date +%Y%m%d_%H%M%S).txt"
    
    mkdir -p "$MINER_REPORTS"
    
    cat > "$report_file" << EOF
=== RELATÃ“RIO DO SISTEMA DE MINERAÃ‡ÃƒO ===
Data: $(date '+%Y-%m-%d %H:%M:%S')

STATUS DO MINERADOR:
- Status: $(is_mining_running && echo "Ativo" || echo "Inativo")
- Worker ID: $(get_worker_id)
- Pool: ${POOLS_MAIN[0]}
- Carteira: ${BTC_WALLET_MAIN:0:15}...

ESTATÃSTICAS:
- Shares Aceitos: $(get_accepted_shares)

SISTEMA:
- CPU Threads: $CPU_THREADS
- Prioridade: $CPU_PRIORITY
- MemÃ³ria MÃ¡xima: ${MAX_MEMORY}MB
- OtimizaÃ§Ã£o: $OPTIMIZATION_LEVEL

=== FIM DO RELATÃ“RIO ===
EOF
    
    echo "RelatÃ³rio gerado: $report_file"
}

cleanup_system() {
    echo "Limpando sistema..."
    
    # Limpar temporÃ¡rios
    rm -rf "$MINER_TEMP"/* 2>/dev/null
    
    # Limpar cache antigo
    find "$MINER_CACHE" -type f -mtime +7 -delete 2>/dev/null
    
    echo "Limpeza concluÃ­da!"
}

update_xmrig() {
    echo "Atualizando XMRig..."
    
    # Fazer backup
    if [ -f "$MINER_BIN/xmrig" ]; then
        cp "$MINER_BIN/xmrig" "$MINER_BACKUP/xmrig_backup_$(date +%s)" 2>/dev/null
    fi
    
    # Reinstalar
    if install_xmrig_complete; then
        echo "âœ… XMRig atualizado com sucesso"
    else
        echo "âŒ Falha na atualizaÃ§Ã£o do XMRig"
    fi
}

security_check() {
    echo "=== VERIFICAÃ‡ÃƒO DE SEGURANÃ‡A ==="
    echo ""
    
    echo "1. Verificando processos..."
    ps aux | grep -E "(xmrig|miner)" | grep -v grep 2>/dev/null || echo "Nenhum processo encontrado"
    
    echo ""
    echo "2. Verificando arquivos do sistema..."
    if [ -f "$MINER_BIN/xmrig" ]; then
        echo "âœ… XMRig encontrado"
    else
        echo "âŒ XMRig nÃ£o encontrado"
    fi
    
    echo ""
    echo "VerificaÃ§Ã£o concluÃ­da!"
}

setup_security() {
    echo "Configurando seguranÃ§a..."
    
    mkdir -p "$MINER_SECURITY"
    
    # Gerar chaves
    echo "API_KEY_MAIN=$API_KEY_MAIN" > "$MINER_SECURITY/keys.conf" 2>/dev/null
    echo "API_KEY_ADMIN=$API_KEY_ADMIN" >> "$MINER_SECURITY/keys.conf" 2>/dev/null
    
    echo "âœ… SeguranÃ§a configurada"
}

show_credits() {
    clear
    echo -e "${COLOR_TITLE}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                           BITCOIN MINER ULTIMATE                                â•‘"
    echo "â•‘                               v10.0 - Sistema Completo                         â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
    echo ""
    echo -e "${COLOR_INFO}ğŸ¯ SISTEMA PROFISSIONAL DE MINERAÃ‡ÃƒO BITCOIN${NC}"
    echo ""
    echo -e "${COLOR_SUCCESS}âœ… Sistema de mineraÃ§Ã£o Bitcoin/XMR completo${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Dashboard em tempo real${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Web Dashboard${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Sistema de logs para Discord${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Editor de scripts integrado${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Task Manager avanÃ§ado${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Monitoramento 24/7${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Backup e restore automÃ¡tico${NC}"
    echo ""
    echo -e "${COLOR_WARNING}âš ï¸  Desenvolvido para Termux - Use com responsabilidade${NC}"
    echo ""
    read -p "Pressione Enter para continuar..."
}

# ============================================================================
# MENU PRINCIPAL COMPLETO
# ============================================================================

show_main_menu() {
    while true; do
        clear
        show_dashboard
        
        echo ""
        echo -e "${COLOR_MENU}ğŸ® MENU PRINCIPAL - v10.0${NC}"
        echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo ""
        echo -e "  ${BOLD}1)${NC} ${GREEN}ğŸš€ Iniciar MineraÃ§Ã£o${NC}"
        echo -e "  ${BOLD}2)${NC} ${RED}ğŸ›‘ Parar MineraÃ§Ã£o${NC}"
        echo -e "  ${BOLD}3)${NC} ${YELLOW}ğŸ”„ Reiniciar Minerador${NC}"
        echo -e "  ${BOLD}4)${NC} ${CYAN}ğŸ“Š Dashboard Detalhado${NC}"
        echo -e "  ${BOLD}5)${NC} ${MAGENTA}ğŸ“‹ Visualizar Logs${NC}"
        echo -e "  ${BOLD}6)${NC} ${ORANGE}ğŸ§¹ Limpar Logs${NC}"
        echo -e "  ${BOLD}7)${NC} ${TEAL}âš¡ Otimizar Sistema${NC}"
        echo -e "  ${BOLD}8)${NC} ${PURPLE}ğŸ’¾ Backup Sistema${NC}"
        echo -e "  ${BOLD}9)${NC} ${BLUE}ğŸŒ Web Dashboard${NC}"
        echo -e "  ${BOLD}10)${NC} ${PINK}ğŸ“ Editor de Scripts${NC}"
        echo -e "  ${BOLD}11)${NC} ${LIME}ğŸ“‹ Task Manager${NC}"
        echo -e "  ${BOLD}12)${NC} ${GOLD}ğŸ”§ ConfiguraÃ§Ãµes${NC}"
        echo -e "  ${BOLD}13)${NC} ${MAGENTA}ğŸ“ˆ EstatÃ­sticas${NC}"
        echo -e "  ${BOLD}14)${NC} ${ORANGE}ğŸ” SeguranÃ§a${NC}"
        echo -e "  ${BOLD}15)${NC} ${TEAL}ğŸŒ Testar ConexÃ£o${NC}"
        echo -e "  ${BOLD}16)${NC} ${PURPLE}ğŸ‘› Mudar Carteira${NC}"
        echo -e "  ${BOLD}17)${NC} ${BLUE}ğŸƒâ€â™‚ï¸ Benchmark${NC}"
        echo -e "  ${BOLD}18)${NC} ${PINK}ğŸ“œ RelatÃ³rios${NC}"
        echo -e "  ${BOLD}19)${NC} ${LIME}ğŸ—‘ï¸  Limpeza${NC}"
        echo -e "  ${BOLD}20)${NC} ${GOLD}ğŸ“¨ Testar Discord${NC}"
        echo -e "  ${BOLD}21)${NC} ${RED}ğŸ”„ Atualizar XMRig${NC}"
        echo -e "  ${BOLD}22)${NC} ${GREEN}ğŸ—ï¸  Configurar SeguranÃ§a${NC}"
        echo -e "  ${BOLD}23)${NC} ${YELLOW}ğŸ¯ CrÃ©ditos${NC}"
        echo -e "  ${BOLD}0)${NC} ${RED}ğŸšª Sair${NC}"
        echo ""
        echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
        echo ""
        
        echo -ne "${COLOR_INPUT}Selecione uma opÃ§Ã£o (0-23): ${NC}"
        read choice
        
        case $choice in
            1) start_mining; sleep 2 ;;
            2) stop_mining; sleep 2 ;;
            3) restart_mining; sleep 2 ;;
            4) clear; show_dashboard; read -p "Pressione Enter para continuar..." ;;
            5) 
                echo "Tipo de logs (system, miner, error, all):"
                read log_type
                view_logs "$log_type"
                read -p "Pressione Enter para continuar..."
                ;;
            6) clear_logs; sleep 1 ;;
            7) optimize_system; sleep 1 ;;
            8) backup_system; sleep 1 ;;
            9) 
                echo "1) Iniciar Web Dashboard"
                echo "2) Parar Web Dashboard"
                read web_choice
                case $web_choice in
                    1) start_web_dashboard; sleep 1 ;;
                    2) stop_web_dashboard; sleep 1 ;;
                esac
                read -p "Pressione Enter para continuar..."
                ;;
            10) script_editor ;;
            11) task_manager ;;
            12) 
                echo "1) Ver configuraÃ§Ã£o atual"
                echo "2) Restaurar configuraÃ§Ã£o padrÃ£o"
                read config_choice
                case $config_choice in
                    1) 
                        echo "=== CONFIGURAÃ‡ÃƒO ATUAL ==="
                        cat "$MINER_CONFIG/config.json" 2>/dev/null || echo "ConfiguraÃ§Ã£o nÃ£o encontrada"
                        read -p "Pressione Enter para continuar..."
                        ;;
                    2)
                        create_configuration
                        ;;
                esac
                ;;
            13) 
                echo "=== ESTATÃSTICAS DETALHADAS ==="
                echo "Shares Aceitos: $(get_accepted_shares)"
                echo "Status: $(is_mining_running && echo "Ativo" || echo "Inativo")"
                read -p "Pressione Enter para continuar..."
                ;;
            14) security_check; read -p "Pressione Enter para continuar..." ;;
            15) test_pool_connection; read -p "Pressione Enter para continuar..." ;;
            16) 
                echo "Nova carteira Bitcoin:"
                read new_wallet
                change_wallet "$new_wallet"
                sleep 2
                ;;
            17) run_benchmark; read -p "Pressione Enter para continuar..." ;;
            18) generate_report; read -p "Pressione Enter para continuar..." ;;
            19) cleanup_system; sleep 1 ;;
            20) discord_send "Teste de notificaÃ§Ã£o do sistema" "3447003" "ğŸ§ª TESTE DE SISTEMA"; sleep 1 ;;
            21) update_xmrig; sleep 2 ;;
            22) setup_security; sleep 1 ;;
            23) show_credits ;;
            0) 
                echo "Encerrando sistema..."
                log_system "Sistema encerrado pelo usuÃ¡rio"
                exit 0
                ;;
            *) echo -e "${COLOR_ERROR}OpÃ§Ã£o invÃ¡lida!${NC}"; sleep 1 ;;
        esac
    done
}

# ============================================================================
# INSTALAÃ‡ÃƒO COMPLETA DO SISTEMA
# ============================================================================

install_complete_system() {
    clear
    
    echo -e "${COLOR_TITLE}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                BITCOIN MINER ULTIMATE - INSTALAÃ‡ÃƒO COMPLETA                     â•‘"
    echo "â•‘                               v10.0 - Sistema Profissional                      â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
    echo ""
    echo -e "${COLOR_INFO}Este sistema inclui funcionalidades profissionais:${NC}"
    echo ""
    echo -e "${COLOR_SUCCESS}âœ… Sistema de mineraÃ§Ã£o Bitcoin/XMR completo${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Dashboard em tempo real${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Web Dashboard${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Sistema de logs para Discord${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Editor de scripts integrado${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Task Manager avanÃ§ado${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Monitoramento 24/7${NC}"
    echo -e "${COLOR_SUCCESS}âœ… Backup e restore automÃ¡tico${NC}"
    echo ""
    echo -e "${COLOR_WARNING}âš ï¸  A instalaÃ§Ã£o pode levar vÃ¡rios minutos.${NC}"
    echo -e "${COLOR_WARNING}âš ï¸  Certifique-se de ter boa conexÃ£o com a internet.${NC}"
    echo ""
    
    read -p "Deseja continuar com a instalaÃ§Ã£o? (s/n): " confirm
    if [ "$confirm" != "s" ] && [ "$confirm" != "S" ]; then
        echo "InstalaÃ§Ã£o cancelada."
        exit 0
    fi
    
    # Passo 1: Criar estrutura de diretÃ³rios
    log_system "Passo 1/10: Criando estrutura de diretÃ³rios..."
    mkdir -p "$MINER_ROOT"
    mkdir -p "$MINER_BIN"
    mkdir -p "$MINER_CONFIG"
    mkdir -p "$MINER_LOGS"
    mkdir -p "$MINER_STATS"
    mkdir -p "$MINER_SCRIPTS"
    mkdir -p "$MINER_BACKUP"
    mkdir -p "$MINER_TEMP"
    mkdir -p "$MINER_CACHE"
    mkdir -p "$MINER_WEB"
    mkdir -p "$MINER_API"
    mkdir -p "$MINER_PLUGINS"
    mkdir -p "$MINER_HOOKS"
    mkdir -p "$MINER_JOBS"
    mkdir -p "$MINER_ALERTS"
    mkdir -p "$MINER_REPORTS"
    mkdir -p "$MINER_SECURITY"
    
    # Inicializar sistema de logs
    init_log_system
    
    # Passo 2: Instalar dependÃªncias
    log_system "Passo 2/10: Instalando dependÃªncias do sistema..."
    pkg update -y > /dev/null 2>&1
    pkg install -y wget curl tar git python cmake make build-essential libuv libuv-dev openssl libhwloc ncurses-utils -y > /dev/null 2>&1
    
    # Passo 3: Instalar XMRig
    log_system "Passo 3/10: Instalando XMRig..."
    if ! install_xmrig_complete; then
        log_error "Falha crÃ­tica na instalaÃ§Ã£o do XMRig"
        echo "âŒ A instalaÃ§Ã£o falhou. Verifique sua conexÃ£o com a internet."
        exit 1
    fi
    
    # Passo 4: Criar configuraÃ§Ãµes
    log_system "Passo 4/10: Criando configuraÃ§Ãµes do sistema..."
    create_configuration
    
    # Passo 5: Configurar monitoramento
    log_system "Passo 5/10: Configurando sistema de monitoramento..."
    start_monitoring_system
    
    # Passo 6: Configurar seguranÃ§a
    log_system "Passo 6/10: Configurando sistema de seguranÃ§a..."
    setup_security
    
    # Passo 7: Criar scripts bÃ¡sicos
    log_system "Passo 7/10: Criando scripts bÃ¡sicos..."
    
    # Script de inÃ­cio de mineraÃ§Ã£o
    cat > "$MINER_SCRIPTS/start_mining.sh" << 'EOF'
#!/data/data/com.termux/files/usr/bin/bash
cd /data/data/com.termux/files/home/bitcoin_miner_pro
./bin/xmrig -c config/config.json
EOF
    chmod +x "$MINER_SCRIPTS/start_mining.sh"
    
    # Passo 8: Criar plugins de exemplo
    log_system "Passo 8/10: Criando plugins de exemplo..."
    
    cat > "$MINER_PLUGINS/example_plugin.sh" << 'EOF'
#!/data/data/com.termux/files/usr/bin/bash
# Plugin de exemplo
echo "âœ… Plugin de exemplo carregado com sucesso!"
echo "Data: $(date)"
EOF
    chmod +x "$MINER_PLUGINS/example_plugin.sh"
    
    # Passo 9: Backup inicial
    log_system "Passo 9/10: Criando backup inicial do sistema..."
    backup_system
    
    # FinalizaÃ§Ã£o
    clear
    echo -e "${COLOR_SUCCESS}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    INSTALAÃ‡ÃƒO CONCLUÃDA COM SUCESSO!                           â•‘"
    echo "â•‘                              SISTEMA PRONTO PARA USO                           â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
    echo ""
    echo -e "${COLOR_INFO}ğŸ“ DiretÃ³rio do sistema:${NC} $MINER_ROOT"
    echo -e "${COLOR_INFO}ğŸ’° Carteira Bitcoin:${NC} ${BTC_WALLET_MAIN:0:10}..."
    echo -e "${COLOR_INFO}âš¡ XMRig instalado:${NC} Sim"
    echo -e "${COLOR_INFO}ğŸ‘· Worker ID:${NC} $(get_worker_id)"
    echo -e "${COLOR_INFO}ğŸŒ Pool padrÃ£o:${NC} ${POOLS_MAIN[0]}"
    echo ""
    echo -e "${COLOR_SUCCESS}âœ… Sistema instalado e configurado com sucesso!${NC}"
    echo ""
    echo -e "${COLOR_WARNING}âš ï¸  Para iniciar a mineraÃ§Ã£o, selecione a opÃ§Ã£o 1 no menu.${NC}"
    echo -e "${COLOR_WARNING}âš ï¸  O sistema iniciarÃ¡ automaticamente em 10 segundos...${NC}"
    
    sleep 10
    
    # Iniciar menu principal
    show_main_menu
}

# ============================================================================
# INICIALIZAÃ‡ÃƒO DO SISTEMA
# ============================================================================

# Verificar se o sistema jÃ¡ estÃ¡ instalado
if [ -d "$MINER_ROOT" ] && [ -f "$MINER_BIN/xmrig" ] && [ -f "$MINER_CONFIG/config.json" ]; then
    init_log_system
    log_system "Sistema detectado, iniciando menu principal..."
    show_main_menu
else
    log_system "Sistema nÃ£o instalado, iniciando instalaÃ§Ã£o completa..."
    install_complete_system
fi
